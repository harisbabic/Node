// /d/Node/utils

#!/bin/bash
# continue-master-setup.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_name=$1
log "$project_name"

# Parse command line options
verbose=false
while getopts "v" opt; do
  case $opt in
    v) verbose=true ;;
    *) echo "Usage: $0 [-v] <project-name>"; exit 1 ;;
  esac
done
shift $((OPTIND-1))

if $verbose; then
  set -x
fi

if [ -z "$project_name" ]; then
  echo "Usage: $0 [-v] <project-name>"
  exit 1
fi

project_dir="/d/Node/projects/$project_name"
utils_dir="/d/Node/utils"

run_script() {
  local script=$1
  shift
  log "Running $script..."
  if [ -f "$utils_dir/$script" ]; then
    if ! "$utils_dir/$script" "$@"; then
      error_exit "Script $script failed. Stopping setup."
    fi
  else
    log "Warning: $script not found. Skipping..."
  fi
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

cleanup() {
  log "Setup interrupted. Cleaning up..."
  # Add cleanup actions here
  # For example, you might want to remove partially created directories
  # rm -rf "$project_dir"
}

trap cleanup EXIT

# Client setup
run_script setup-redux.sh "$project_dir"
# Server setup
read -s -p "Enter PostgreSQL password for ${project_name}_user: " db_password
echo
run_script setup-postgresql.sh "$project_name" "${project_name}_user" "$db_password"
run_script setup-auth.sh "$project_name"
run_script run-migrations.sh "$project_name" "${project_name}_user" "$db_password"
run_script enhance-error-handling.sh "$project_name"

# API Route setup
read -p "Do you want to create an API route? (y/n) " create_route
if [[ $create_route =~ ^[Yy]$ ]]; then
  read -p "Enter the route name: " route_name
  run_script create-api-route.sh "$project_name" "$route_name"
fi

# Noloco-like functionality setup
read -p "Do you want to set up Noloco-like functionalities? (y/n) " setup_noloco
if [[ $setup_noloco =~ ^[Yy]$ ]]; then
  run_script setup-data-modeling.sh "$project_dir"
  run_script setup-api-generation.sh "$project_dir"
  run_script setup-rbac.sh "$project_dir"
  run_script setup-workflows.sh "$project_dir"
  run_script setup-dynamic-ui.sh "$project_dir"
  run_script setup-file-management.sh "$project_dir"
  run_script setup-email-templates.sh "$project_dir"
  run_script setup-dashboard.sh "$project_dir"
  run_script setup-noloco-theme.sh "$project_dir" "both"
fi

log "Project setup complete."
echo "Project $project_name has been set up successfully!"

# Remove the trap before exiting normally
trap - EXIT
#!/bin/bash

# create-api-route.sh
# Usage: create-api-route.sh <project-name> <route-name>
# Description: Creates a new API route with controller and model for PostgreSQL

set -euo pipefail

if [ $# -ne 2 ]; then
    echo "Usage: $0 <project-name> <route-name>"
    exit 1
fi

project_name=$1
route_name=$2

project_dir="/d/Node/projects/$project_name"
src_dir="$project_dir/server/src"
routes_dir="$src_dir/routes"
controllers_dir="$src_dir/controllers"
models_dir="$src_dir/models"

# Ensure directories exist
mkdir -p "$routes_dir" "$controllers_dir" "$models_dir"

# Create route file
cat << EOF > "$routes_dir/${route_name}.js"
const express = require('express');
const router = express.Router();
const ${route_name}Controller = require('../controllers/${route_name}');

router.get('/', ${route_name}Controller.getAll);
router.post('/', ${route_name}Controller.create);
router.get('/:id', ${route_name}Controller.getById);
router.put('/:id', ${route_name}Controller.update);
router.delete('/:id', ${route_name}Controller.delete);

module.exports = router;
EOF

# Create controller file
cat << EOF > "$controllers_dir/${route_name}.js"
const ${route_name}Model = require('../models/${route_name}');

exports.getAll = async (req, res) => {
  try {
    const items = await ${route_name}Model.findAll();
    res.json(items);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.create = async (req, res) => {
  try {
    const newItem = await ${route_name}Model.create(req.body);
    res.status(201).json(newItem);
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};

exports.getById = async (req, res) => {
  try {
    const item = await ${route_name}Model.findByPk(req.params.id);
    if (!item) {
      return res.status(404).json({ message: 'Item not found' });
    }
    res.json(item);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};

exports.update = async (req, res) => {
  try {
    const [updated] = await ${route_name}Model.update(req.body, {
      where: { id: req.params.id }
    });
    if (updated) {
      const updatedItem = await ${route_name}Model.findByPk(req.params.id);
      res.json(updatedItem);
    } else {
      res.status(404).json({ message: 'Item not found' });
    }
  } catch (error) {
    res.status(400).json({ message: error.message });
  }
};

exports.delete = async (req, res) => {
  try {
    const deleted = await ${route_name}Model.destroy({
      where: { id: req.params.id }
    });
    if (deleted) {
      res.json({ message: 'Item deleted' });
    } else {
      res.status(404).json({ message: 'Item not found' });
    }
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
};
EOF

# Create model file
cat << EOF > "$models_dir/${route_name}.js"
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const ${route_name} = sequelize.define('${route_name}', {
  // Define your model fields here
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  // Add more fields as needed
});

module.exports = ${route_name};
EOF

echo "API route, controller, and model for $route_name created successfully in $project_name"
#!/bin/bash
# generate-api-service.sh

set -euo pipefail

project_dir="$1"
api_name="$2"

if [ -z "$project_dir" ] || [ -z "$api_name" ]; then
  echo "Usage: $0 <project-dir> <api-name>"
  exit 1
fi

client_dir="$project_dir/client"
cd "$client_dir" || exit 1

mkdir -p src/services

cat << EOF > "src/services/${api_name}Service.js"
import axios from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_BASE_URL || 'http://localhost:3000/api';

const ${api_name}Service = {
  // Previous methods remain the same

  // Add a new method for handling file uploads
  upload: async (endpoint, file, onUploadProgress) => {
    const formData = new FormData();
    formData.append('file', file);

    try {
      const response = await axios.post(\`\${API_BASE_URL}/\${endpoint}\`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data'
        },
        onUploadProgress
      });
      return response.data;
    } catch (error) {
      console.error('Error uploading file:', error);
      throw error;
    }
  },

  // Add a method for cancellable requests
  getCancellable: (endpoint) => {
    const source = axios.CancelToken.source();
    const promise = axios.get(\`\${API_BASE_URL}/\${endpoint}\`, {
      cancelToken: source.token
    });
    return { promise, cancel: () => source.cancel('Request cancelled') };
  }
};

export default ${api_name}Service;
EOF

echo "Enhanced API service ${api_name}Service created in $client_dir/src/services"
#!/bin/bash
# generate-config.sh

project_dir="$1"
config_type="$2"

if [ -z "$project_dir" ] || [ -z "$config_type" ]; then
  echo "Usage: $0 <project-dir> <config-type>"
  echo "Config types: webpack, babel, tsconfig"
  exit 1
fi

client_dir="$project_dir/client"
# cd "$client_dir"

case "$config_type" in
  webpack)
    cat << EOF > "$client_dir/webpack.config.js"
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');

module.exports = {
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    clean: true,
  },
  module: {
    rules: [
      {
        test: /\.(js|jsx)$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
        },
      },
      {
        test: /\.(scss|css)$/,
        use: [MiniCssExtractPlugin.loader, 'css-loader', 'sass-loader'],
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: './public/index.html',
    }),
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css',
    }),
  ],
  devServer: {
    static: path.join(__dirname, 'dist'),
    port: 3000,
    hot: true,
  },
  optimization: {
    moduleIds: 'deterministic',
    runtimeChunk: 'single',
    splitChunks: {
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
      },
    },
  },
};
EOF
    echo "Webpack config generated in $client_dir"
    ;;
  babel)
    cat << EOF > "$client_dir/.babelrc"
{
  "presets": [
    ["@babel/preset-env", {
      "targets": {
        "browsers": [">0.25%", "not ie 11", "not op_mini all"]
      }
    }],
    "@babel/preset-react"
  ],
  "plugins": [
    "@babel/plugin-proposal-class-properties",
    "@babel/plugin-transform-runtime"
  ]
}
EOF
    echo "Babel config generated in $client_dir"
    ;;
  tsconfig)
    cat << EOF > "$client_dir/tsconfig.json"
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": "src"
  },
  "include": ["src"]
}
EOF
    echo "TypeScript config generated in $client_dir"
    ;;
  *)
    echo "Invalid config type. Choose 'webpack', 'babel', or 'tsconfig'."
    exit 1
    ;;
esac
#!/bin/bash
# generate-layout.sh

project_dir="$1"
layout_type="$2"

if [ -z "$project_dir" ] || [ -z "$layout_type" ]; then
  echo "Usage: $0 <project-dir> <layout-type>"
  echo "Layout types: dashboard, landing"
  exit 1
fi

client_dir="$project_dir/client"
# cd "$client_dir"

mkdir -p "$client_dir/src/layouts"

generate_layout() {
  local name="$1"
  local file="$client_dir/src/layouts/${name}Layout.js"

  cat << EOF > "$file"
import React from 'react';
import styled from 'styled-components';

const ${name}Wrapper = styled.div\`
  display: flex;
  flex-direction: column;
  min-height: 100vh;
\`;

const Header = styled.header\`
  padding: 1rem;
  background-color: \${({ theme }) => theme.colors.background};
\`;

const Main = styled.main\`
  flex: 1;
  padding: 1rem;
\`;

const Footer = styled.footer\`
  padding: 1rem;
  background-color: \${({ theme }) => theme.colors.background};
\`;

const ${name}Layout = ({ children }) => (
  <${name}Wrapper>
    <Header>Header</Header>
    <Main>{children}</Main>
    <Footer>Footer</Footer>
  </${name}Wrapper>
);

export default ${name}Layout;
EOF

  echo "${name} layout generated in $file"
}

case "$layout_type" in
  dashboard)
    generate_layout "Dashboard"
    ;;
  landing)
    generate_layout "Landing"
    ;;
  *)
    echo "Invalid layout type. Choose 'dashboard' or 'landing'."
    exit 1
    ;;
esac
#!/bin/bash
# generate-tests.sh

set -e

project_name=$1

if [ -z "$project_name" ]; then
    echo "Usage: $0 <project-name>"
    exit 1
fi

project_dir="/d/Node/projects/$project_name"
tests_dir="$project_dir/server/tests"

echo "Creating test/unit and test/integration directories..."
mkdir -p "$tests_dir/unit" "$tests_dir/integration"

# Generate a sample unit test
cat << EOF > "$tests_dir/unit/sample.test.js"
describe('Sample Test', () => {
  it('should pass', () => {
    expect(true).toBe(true);
  });
});
EOF

# Generate a sample integration test
cat << EOF > "$tests_dir/integration/api.test.js"
const request = require('supertest');
const app = require('../../src/app');

describe('API Tests', () => {
  it('should return 200 OK for GET /', async () => {
    const res = await request(app).get('/');
    expect(res.statusCode).toBe(200);
  });
});
EOF

echo "Sample tests generated in $tests_dir"
#!/bin/bash
# init-git.sh
# Usage: ./init-git.sh <project-name>

project_name=$1
project_dir="/d/Node/projects/$project_name"

cd "$project_dir"

# Initialize Git
git init

# Create .gitignore
cat << EOF > .gitignore
# Dependencies
node_modules/
/.pnp
.pnp.js

# Testing
/coverage

# Production
/build

# Misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

# Logs
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Environment variables
.env

# IDE specific files
.idea/
.vscode/
*.swp
*.swo

# Operating System Files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variables file
.env
EOF

git add .
git commit -m "Initial commit"

echo "Git initialized with .gitignore for $project_name"
#!/bin/bash
# master-setup.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_name=$1
log "$project_name"

# Parse command line options
verbose=false
while getopts "v" opt; do
  case $opt in
    v) verbose=true ;;
    *) echo "Usage: $0 [-v] <project-name>"; exit 1 ;;
  esac
done
shift $((OPTIND-1))

if $verbose; then
  set -x
fi

if [ -z "$project_name" ]; then
  echo "Usage: $0 [-v] <project-name>"
  exit 1
fi

project_dir="/d/Node/projects/$project_name"
log "$project_dir"
utils_dir="/d/Node/utils"

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

run_script() {
  local script=$1
  shift
  log "Running $script..."
  if [ -f "$utils_dir/$script" ]; then
    if ! "$utils_dir/$script" "$@"; then
      error_exit "Script $script failed. Stopping setup."
    fi
  else
    log "Warning: $script not found. Skipping..."
  fi
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

cleanup() {
  log "Setup interrupted. Cleaning up..."
  # Add cleanup actions here
  # For example, you might want to remove partially created directories
  # rm -rf "$project_dir"
}

trap cleanup EXIT

# Create project directory
mkdir -p "$project_dir"
cd "$project_dir"

# Core setup
run_script setup-project.sh "$project_name"
run_script set-configs.sh "$project_dir" "$project_name"
run_script generate-tests.sh "$project_name"
run_script init-git.sh "$project_name"

# Client setup
run_script setup-sass.sh "$project_dir"
run_script setup-styled-components.sh "$project_dir"
run_script setup-redux.sh "$project_dir"
run_script setup-redux-actions.sh "$project_name"
run_script generate-config.sh "$project_dir" webpack
run_script generate-config.sh "$project_dir" babel
run_script generate-config.sh "$project_dir" tsconfig
run_script generate-layout.sh "$project_dir" dashboard
run_script setup-state-management.sh "$project_dir" redux
run_script generate-api-service.sh "$project_dir" api
run_script setup-responsive-design.sh "$project_dir"
run_script setup-accessibility.sh "$project_dir"
run_script setup-performance-optimization.sh "$project_dir"

# Optional Client setups
read -p "Do you want to set up animations with Framer Motion? (y/n) " setup_animation
if [[ $setup_animation =~ ^[Yy]$ ]]; then
  run_script setup-animation.sh "$project_dir" framer-motion
fi

read -p "Do you want to set up internationalization (i18n)? (y/n) " setup_i18n
if [[ $setup_i18n =~ ^[Yy]$ ]]; then
  run_script setup-i18n.sh "$project_dir"
fi

read -p "Do you want to set up SEO? (y/n) " setup_seo
if [[ $setup_seo =~ ^[Yy]$ ]]; then
  run_script setup-seo.sh "$project_dir"
fi

read -p "Do you want to set up as a Progressive Web App (PWA)? (y/n) " setup_pwa
if [[ $setup_pwa =~ ^[Yy]$ ]]; then
  run_script setup-pwa.sh "$project_dir"
fi

read -p "Do you want to set up component documentation? (y/n) " setup_component_docs
if [[ $setup_component_docs =~ ^[Yy]$ ]]; then
  run_script setup-component-docs.sh "$project_dir"
fi

# Server setup
read -s -p "Enter PostgreSQL password for ${project_name}_user: " db_password
echo
run_script setup-postgresql.sh "$project_name" "${project_name}_user" "$db_password"
run_script setup-auth.sh "$project_name"
run_script run-migrations.sh "$project_name"

# Noloco-like functionality setup
read -p "Do you want to set up Noloco-like functionalities? (y/n) " setup_noloco
if [[ $setup_noloco =~ ^[Yy]$ ]]; then
  run_script setup-data-modeling.sh "$project_dir"
  run_script setup-api-generation.sh "$project_dir"
  run_script setup-rbac.sh "$project_dir"
  run_script setup-workflows.sh "$project_dir"
  run_script setup-dynamic-ui.sh "$project_dir"
  run_script setup-file-management.sh "$project_dir"
  run_script setup-email-templates.sh "$project_dir"
  run_script setup-dashboard.sh "$project_dir"
  run_script setup-noloco-theme.sh "$project_dir" "both"
fi

log "Project setup complete."
echo "Project $project_name has been set up successfully!"

# Remove the trap before exiting normally
trap - EXIT
#!/bin/bash
# run-migrations.sh


set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_name="$1"
db_user="$2"
db_pass="$3"

if [ -z "$project_name" ] || [ -z "$db_user" ] || [ -z "$db_pass" ]; then
  error_exit "Usage: $0 <project-name> <db-user> <db-pass>"
fi

log "Setting up migrations for $project_name"

project_dir="/d/Node/projects/$project_name"
server_dir="$project_dir/server"

if [ -z "$project_name" ]; then
  echo "Usage: $0 <project-name>"
  exit 1
fi

# Ensure the server directory exists
if [ ! -d "$server_dir" ]; then
  error_exit "Server directory not found: $server_dir"
fi

# Change to the server directory
cd "$server_dir" || error_exit "Failed to change to server directory"

# Ensure PostgreSQL is running
pg_isready || error_exit "PostgreSQL is not running"

# Check if DATABASE_URL is set
if [ -z "${DATABASE_URL:-}" ]; then
  error_exit "DATABASE_URL is not set"
fi

PGPASSWORD="${db_pass}" psql -U postgres -d "${project_name}" -c "GRANT ALL ON SCHEMA public TO ${db_user};"

# Run migrations
log "Running database migrations..."

if ! psql "$DATABASE_URL" -v ON_ERROR_STOP=1 <<-EOSQL
  CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(100) UNIQUE NOT NULL,
    password VARCHAR(100) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
  );
EOSQL
then
  error_exit "Failed to run migrations"
fi

# Add any additional migrations here

log "Database migrations completed successfully."
#!/bin/bash
# set-configs.sh

set -e

project_dir="$1"
project_name="$2"

if [ -z "$project_dir" ] || [ -z "$project_name" ]; then
    echo "Usage: $0 <project-dir> <project-name>"
    exit 1
fi

server_dir="$project_dir/server"
cd "$server_dir" || exit 1

# Create package.json
cat << EOF > ./package.json
{
  "name": "$project_name",
  "version": "1.0.0",
  "description": "Project created with DemTech Master Script Project Setup.",
  "main": "src/index.js",
  "scripts": {
    "start": "node src/index.js",
    "dev": "nodemon src/index.js",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "express": "^4.17.1",
    "pg": "^8.7.1",
    "sequelize": "^6.6.5",
    "dotenv": "^10.0.0",
    "cors": "^2.8.5"
  },
  "devDependencies": {
    "jest": "^27.0.0",
    "supertest": "^6.1.3",
    "nodemon": "^2.0.12"
  }
}
EOF

# Create jest.config.js
cat << EOF > ./jest.config.js
module.exports = {
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.js', '**/?(*.)+(spec|test).js'],
  collectCoverageFrom: ['src/**/*.js'],
  coveragePathIgnorePatterns: ['/node_modules/', '/tests/'],
  coverageReporters: ['text', 'lcov'],
  setupFilesAfterEnv: ['./jest.setup.js']
};
EOF

# Create jest.setup.js
cat << EOF > ./jest.setup.js
// jest.setup.js

require('dotenv').config();

jest.setTimeout(30000);

expect.extend({
  toBeWithinRange(received, floor, ceiling) {
    const pass = received >= floor && received <= ceiling;
    if (pass) {
      return {
        message: () => \`expected \${received} not to be within range \${floor} - \${ceiling}\`,
        pass: true,
      };
    } else {
      return {
        message: () => \`expected \${received} to be within range \${floor} - \${ceiling}\`,
        pass: false,
      };
    }
  },
});

beforeAll(() => {
  console.log('Starting all tests...');
});

afterAll(() => {
  console.log('All tests completed.');
});

if (typeof fetch === 'undefined') {
  global.fetch = require('node-fetch');
}

global.createMockResponse = (data, status = 200) => {
  return new Response(JSON.stringify(data), {
    status,
    headers: { 'Content-Type': 'application/json' },
  });
};

global.wait = (ms) => new Promise(resolve => setTimeout(resolve, ms));

const mockDate = new Date('2024-08-05T12:00:00Z');
global.Date = class extends Date {
  constructor() {
    return mockDate;
  }
};
EOF

echo "Configuration files created successfully for $project_name"
echo "Jest configuration files created in $server_dir"
#!/bin/bash
# setup-accessibility.sh

set -euo pipefail

project_dir="$1"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir>"
  exit 1
fi

client_dir="$project_dir/client"
cd "$client_dir" || exit 1

# Create a FocusTrap component
cat << EOF > src/components/FocusTrap.js
import React, { useRef, useEffect } from 'react';

const FocusTrap = ({ children }) => {
  const trapRef = useRef(null);

  useEffect(() => {
    const trapElement = trapRef.current;
    const focusableElements = trapElement.querySelectorAll(
      'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
    );
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];

    const handleKeyDown = (e) => {
      if (e.key === 'Tab') {
        if (e.shiftKey && document.activeElement === firstElement) {
          e.preventDefault();
          lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
          e.preventDefault();
          firstElement.focus();
        }
      }
    };

    trapElement.addEventListener('keydown', handleKeyDown);
    return () => trapElement.removeEventListener('keydown', handleKeyDown);
  }, []);

  return <div ref={trapRef}>{children}</div>;
};

export default FocusTrap;
EOF

echo "Enhanced accessibility setup completed for $client_dir"
#!/bin/bash
# setup-animation.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"
animation_lib="${2:-framer-motion}"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir> [animation-library]"
fi

client_dir="$project_dir/client"
cd "$client_dir" || error_exit "Failed to change to client directory"

log "Setting up $animation_lib for $client_dir"

case "$animation_lib" in
  framer-motion)
    npm install framer-motion

    # Create a sample animated component
    cat << EOF > src/components/AnimatedBox.js
import React from 'react';
import { motion } from 'framer-motion';

const AnimatedBox = () => (
  <motion.div
    initial={{ opacity: 0, scale: 0.5 }}
    animate={{ opacity: 1, scale: 1 }}
    transition={{ duration: 0.5 }}
    whileHover={{ scale: 1.1 }}
    whileTap={{ scale: 0.9 }}
    style={{
      width: 100,
      height: 100,
      background: 'blue',
      borderRadius: 10,
    }}
  />
);

export default AnimatedBox;
EOF
    ;;
  react-spring)
    npm install react-spring

    # Create a sample animated component
    cat << EOF > src/components/AnimatedBox.js
import React from 'react';
import { useSpring, animated } from 'react-spring';

const AnimatedBox = () => {
  const props = useSpring({
    to: { opacity: 1, scale: 1 },
    from: { opacity: 0, scale: 0.5 },
    config: { duration: 500 },
  });

  return (
    <animated.div
      style={{
        ...props,
        width: 100,
        height: 100,
        background: 'blue',
        borderRadius: 10,
      }}
    />
  );
};

export default AnimatedBox;
EOF
    ;;
  react-transition-group)
    npm install react-transition-group

    # Create a sample animated component
    cat << EOF > src/components/AnimatedBox.js
import React, { useState } from 'react';
import { CSSTransition } from 'react-transition-group';
import './AnimatedBox.css';

const AnimatedBox = () => {
  const [inProp, setInProp] = useState(false);
  return (
    <div>
      <CSSTransition in={inProp} timeout={300} classNames="fade">
        <div className="box" />
      </CSSTransition>
      <button onClick={() => setInProp(!inProp)}>
        Click to Toggle
      </button>
    </div>
  );
};

export default AnimatedBox;
EOF

    # Create CSS for the animated component
    cat << EOF > src/components/AnimatedBox.css
.box {
  width: 100px;
  height: 100px;
  background: blue;
  border-radius: 10px;
}

.fade-enter {
  opacity: 0;
}
.fade-enter-active {
  opacity: 1;
  transition: opacity 300ms ease-in;
}
.fade-exit {
  opacity: 1;
}
.fade-exit-active {
  opacity: 0;
  transition: opacity 300ms ease-in;
}
EOF
    ;;
  *)
    echo "Invalid animation library. Choose 'framer-motion', 'react-spring', or 'react-transition-group'."
    exit 1
    ;;
esac

echo "$animation_lib setup completed for $client_dir directory."
#!/bin/bash
# setup-api-generation.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

server_dir="$project_dir/server"
mkdir -p "$server_dir/src/services" "$server_dir/src/routes"

log "Setting up API generation for $project_dir"

# Create API generation service
cat << EOF > "$server_dir/src/services/apiGenerationService.js"
// src/services/apiGenerationService.js
const express = require('express');
const { query } = require('../utils/db');

class APIGenerationService {
  generateAPI(modelName, fields) {
    const router = express.Router();

    // Create
    router.post('/', async (req, res) => {
      try {
        const keys = Object.keys(req.body);
        const values = Object.values(req.body);
        const sqlQuery = \`INSERT INTO \${modelName} (\${keys.join(', ')}) VALUES (\${values.map((_, i) => '$' + (i + 1)).join(', ')}) RETURNING *\`;
        const result = await query(sqlQuery, values);
        res.status(201).json(result.rows[0]);
      } catch (error) {
        res.status(400).json({ error: error.message });
      }
    });

    // Read all
    router.get('/', async (req, res) => {
      try {
        const result = await query(\`SELECT * FROM \${modelName}\`);
        res.json(result.rows);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Read one
    router.get('/:id', async (req, res) => {
      try {
        const result = await query(\`SELECT * FROM \${modelName} WHERE id = \$1\`, [req.params.id]);
        if (result.rows.length === 0) return res.status(404).json({ message: 'Document not found' });
        res.json(result.rows[0]);
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    // Update
    router.put('/:id', async (req, res) => {
      try {
        const keys = Object.keys(req.body);
        const values = Object.values(req.body);
        const sqlQuery = \`UPDATE \${modelName} SET \${keys.map((key, i) => \`\${key} = \$\${i + 1}\`).join(', ')} WHERE id = \$\${keys.length + 1} RETURNING *\`;
        const result = await query(sqlQuery, [...values, req.params.id]);
        if (result.rows.length === 0) return res.status(404).json({ message: 'Document not found' });
        res.json(result.rows[0]);
      } catch (error) {
        res.status(400).json({ error: error.message });
      }
    });

    // Delete
    router.delete('/:id', async (req, res) => {
      try {
        const result = await query(\`DELETE FROM \${modelName} WHERE id = \$1 RETURNING *\`, [req.params.id]);
        if (result.rows.length === 0) return res.status(404).json({ message: 'Document not found' });
        res.json({ message: 'Document deleted successfully' });
      } catch (error) {
        res.status(500).json({ error: error.message });
      }
    });

    return router;
  }
}

module.exports = new APIGenerationService();
EOF

# Create dynamic API routes file
cat << EOF > "$server_dir/src/routes/dynamicApiRoutes.js"
// src/routes/dynamicApiRoutes.js
const express = require('express');
const apiGenerationService = require('../services/apiGenerationService');
const dataModelingService = require('../services/dataModelingService');

const router = express.Router();

// Function to set up dynamic routes
const setupDynamicRoutes = async () => {
  try {
    const models = await dataModelingService.getModels();
    models.forEach(model => {
      router.use(\`/\${model.name.toLowerCase()}\`, apiGenerationService.generateAPI(model.name, model.fields));
    });
    console.log('Dynamic API routes set up successfully');
  } catch (error) {
    console.error('Error setting up dynamic API routes:', error);
  }
};

// Set up routes immediately and export the router
setupDynamicRoutes();

module.exports = router;
EOF

log "API generation setup completed for $project_dir"
#!/bin/bash
# setup-auth.sh
# Usage: ./setup-auth.sh <project-name>

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_name=$1

if [ -z "$project_name" ]; then
  echo "Usage: $0 <project-name>"
  exit 1
fi

project_dir="/d/Node/projects/$project_name"
server_dir="$project_dir/server"

# Install necessary packages
cd "$project_dir"
npm install jsonwebtoken bcryptjs

# Create an authentication middleware
mkdir -p "$server_dir/src/middleware"
cat << EOF > "$server_dir/src/middleware/auth.js"
// projects/grow-tracking-app/server/src/middleware/auth.js
const jwt = require('jsonwebtoken');

module.exports = function (req, res, next) {
  // Get token from header
  const token = req.header('x-auth-token');

  // Check if no token
  if (!token) {
    return res.status(401).json({ msg: 'No token, authorization denied' });
  }

  // Verify token
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    req.user = decoded.user;
    next();
  } catch (err) {
    res.status(401).json({ msg: 'Token is not valid' });
  }
};
EOF

# Create authentication routes
mkdir -p "$server_dir/src/routes"
cat << EOF > "$server_dir/src/routes/auth.js"
const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const jwt = require('jsonwebtoken');
const User = require('../models/User');
const auth = require('../middleware/auth');
require('dotenv').config();

// @route   POST api/auth/register
// @desc    Register user
// @access  Public
router.post('/register', async (req, res) => {
  const { name, email, password } = req.body;

  try {
    let user = await User.findOne({ email });
    if (user) {
      return res.status(400).json({ msg: 'User already exists' });
    }

    user = new User({
      name,
      email,
      password,
    });

    const salt = await bcrypt.genSalt(10);
    user.password = await bcrypt.hash(password, salt);

    await user.save();

    const payload = {
      user: {
        id: user.id,
      },
    };

    jwt.sign(
      payload,
      process.env.JWT_SECRET,
      { expiresIn: 3600 },
      (err, token) => {
        if (err) throw err;
        res.json({ token });
      }
    );
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
});

// @route   POST api/auth/login
// @desc    Authenticate user & get token
// @access  Public
router.post('/login', async (req, res) => {
  const { email, password } = req.body;

  try {
    let user = await User.findOne({ email });
    if (!user) {
      return res.status(400).json({ msg: 'Invalid Credentials' });
    }

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
      return res.status(400).json({ msg: 'Invalid Credentials' });
    }

    const payload = {
      user: {
        id: user.id,
      },
    };

    jwt.sign(
      payload,
      process.env.JWT_SECRET,
      { expiresIn: 3600 },
      (err, token) => {
        if (err) throw err;
        res.json({ token });
      }
    );
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server error');
  }
});

// @route   GET api/auth/user
// @desc    Get logged in user
// @access  Private
router.get('/user', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user.id).select('-password');
    res.json(user);
  } catch (err) {
    console.error(err.message);
    res.status(500).send('Server Error');
  }
});

module.exports = router;
EOF

# Update .env file with JWT secret
echo "JWT_SECRET=mySecretKey" >> "$server_dir/.env"

echo "Authentication and authorization set up for $project_name"
#!/bin/bash
# setup-component-docs.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

client_dir="$project_dir/client"
cd "$client_dir" || error_exit "Failed to change to client directory"

log "Setting up component documentation for $client_dir"

# Install Storybook
npx sb init --builder webpack5

# Install additional addons
npm install --save-dev @storybook/addon-a11y @storybook/addon-viewport @storybook/addon-docs

# Update .storybook/main.js to include addons
cat << EOF > .storybook/main.js
module.exports = {
  stories: ['../src/**/*.stories.mdx', '../src/**/*.stories.@(js|jsx|ts|tsx)'],
  addons: [
    '@storybook/addon-links',
    '@storybook/addon-essentials',
    '@storybook/preset-create-react-app',
    '@storybook/addon-a11y',
    '@storybook/addon-viewport',
  ],
  framework: '@storybook/react',
  core: {
    builder: 'webpack5',
  },
};
EOF

# Create a sample story for the AnimatedBox component
mkdir -p src/stories
cat << EOF > src/stories/AnimatedBox.stories.js
import React from 'react';
import AnimatedBox from '../components/AnimatedBox';

export default {
  title: 'Components/AnimatedBox',
  component: AnimatedBox,
  argTypes: {
    backgroundColor: { control: 'color' },
  },
};

const Template = (args) => <AnimatedBox {...args} />;

export const Default = Template.bind({});
Default.args = {
  backgroundColor: 'blue',
};

export const CustomColor = Template.bind({});
CustomColor.args = {
  backgroundColor: 'red',
};
EOF

# Create a documentation page for AnimatedBox
cat << EOF > src/stories/AnimatedBox.stories.mdx
import { Meta, Story, Canvas, ArgsTable } from '@storybook/addon-docs';
import AnimatedBox from '../components/AnimatedBox';

<Meta title="Components/AnimatedBox" component={AnimatedBox} />

# AnimatedBox

An animated box component that scales on hover and tap.

<Canvas>
  <Story name="Default">
    <AnimatedBox />
  </Story>
</Canvas>

## Props

<ArgsTable of={AnimatedBox} />

## Usage

Import the component and use it in your React application:

\`\`\`jsx
import AnimatedBox from './components/AnimatedBox';

function App() {
  return (
    <div>
      <AnimatedBox />
    </div>
  );
}
\`\`\`
EOF

# Add Storybook scripts to package.json
npm pkg set scripts.storybook="start-storybook -p 6006 -s public"
npm pkg set scripts.build-storybook="build-storybook -s public"

log "Component documentation setup completed for $client_dir directory."
#!/bin/bash
# setup-dashboard.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

log "Setting up dashboard for $project_dir"

mkdir -p "$project_dir/client/src/components/Dashboard"

# Create Dashboard component
cat << EOF > "$project_dir/client/src/components/Dashboard/Dashboard.js"
import React, { useState, useEffect } from 'react';
import DynamicTable from '../DynamicUI/DynamicTable';

const Dashboard = () => {
  const [dashboardData, setDashboardData] = useState({});

  useEffect(() => {
    // Fetch dashboard data from API
    const fetchDashboardData = async () => {
      // Replace with actual API call
      const response = await fetch('/api/dashboard');
      const data = await response.json();
      setDashboardData(data);
    };

    fetchDashboardData();
  }, []);

  return (
    <div>
      <h1>Dashboard</h1>
      {Object.entries(dashboardData).map(([key, value]) => (
        <div key={key}>
          <h2>{key}</h2>
          {Array.isArray(value) ? (
            <DynamicTable
              data={value}
              columns={Object.keys(value[0]).map(col => ({ key: col, label: col }))}
            />
          ) : (
            <p>{value}</p>
          )}
        </div>
      ))}
    </div>
  );
};

export default Dashboard;
EOF

# Create DashboardWidget component
cat << EOF > "$project_dir/client/src/components/Dashboard/DashboardWidget.js"
import React from 'react';

const DashboardWidget = ({ title, value, icon }) => {
  return (
    <div className="dashboard-widget">
      <div className="widget-icon">{icon}</div>
      <div className="widget-content">
        <h3>{title}</h3>
        <p>{value}</p>
      </div>
    </div>
  );
};

export default DashboardWidget;
EOF

# Update App.js to include Dashboard
app_js_path="$project_dir/client/src/App.js"
if [ -f "$app_js_path" ]; then
  sed -i "/import React/a import Dashboard from './components/Dashboard/Dashboard';" "$app_js_path"
  sed -i "/<div className=\"App\">/a <Dashboard />" "$app_js_path"
else
  log "Warning: App.js not found at $app_js_path. Dashboard import not added."
fi

log "Dashboard setup completed for $project_dir"
#!/bin/bash
# setup-data-modeling.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"
client_dir="$project_dir/client"

log "Setting up data modeling for $project_dir"

cd "$client_dir" || error_exit "Failed to change to client directory"

log "Installing class-variance-authority..."
npm install class-variance-authority

# Install Tailwind CSS
log "Installing Tailwind CSS..."
npm install -D tailwindcss postcss autoprefixer
npx tailwindcss init -p

# Update tailwind.config.js
log "Updating Tailwind CSS configuration..."
cat << EOF > tailwind.config.js
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
}
EOF

# Update src/index.css
log "Updating src/index.css with Tailwind directives..."
cat << EOF > src/index.css
@tailwind base;
@tailwind components;
@tailwind utilities;
EOF

# Initialize shadcn-ui
npx shadcn-ui@latest init
log "Initializing shadcn-ui..."
echo '{
  "style": "default",
  "rsc": false,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/index.css",
    "baseColor": "slate",
    "cssVariables": true
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils"
  }
}' > components.json

# Add alert component
log "Adding shadcn-ui alert component..."
echo "y" | npx shadcn-ui@latest add alert || error_exit "Failed to add shadcn-ui alert component"

log "Data modeling setup completed for $client_dir"
#!/bin/bash
# setup-dynamic-ui.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

log "Setting up dynamic UI for $project_dir"

mkdir -p "$project_dir/client/src/components/DynamicUI"

# Create DynamicForm component
cat << EOF > "$project_dir/client/src/components/DynamicUI/DynamicForm.js"
import React from 'react';
import { useForm } from 'react-hook-form';

const DynamicForm = ({ fields, onSubmit }) => {
  const { register, handleSubmit, formState: { errors } } = useForm();

  const renderField = (field) => {
    switch (field.type) {
      case 'text':
      case 'email':
      case 'number':
        return (
          <input
            type={field.type}
            {...register(field.name, field.validation)}
            placeholder={field.placeholder}
          />
        );
      case 'select':
        return (
          <select {...register(field.name, field.validation)}>
            {field.options.map((option, index) => (
              <option key={index} value={option.value}>
                {option.label}
              </option>
            ))}
          </select>
        );
      case 'textarea':
        return (
          <textarea
            {...register(field.name, field.validation)}
            placeholder={field.placeholder}
          />
        );
      default:
        return null;
    }
  };

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      {fields.map((field, index) => (
        <div key={index}>
          <label>{field.label}</label>
          {renderField(field)}
          {errors[field.name] && <span>{errors[field.name].message}</span>}
        </div>
      ))}
      <button type="submit">Submit</button>
    </form>
  );
};

export default DynamicForm;
EOF

# Create DynamicTable component
cat << EOF > "$project_dir/client/src/components/DynamicUI/DynamicTable.js"
import React from 'react';

const DynamicTable = ({ data, columns }) => {
  return (
    <table>
      <thead>
        <tr>
          {columns.map((column, index) => (
            <th key={index}>{column.label}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {data.map((row, rowIndex) => (
          <tr key={rowIndex}>
            {columns.map((column, columnIndex) => (
              <td key={columnIndex}>{row[column.key]}</td>
            ))}
          </tr>
        ))}
      </tbody>
    </table>
  );
};

export default DynamicTable;
EOF

echo "Dynamic UI components setup completed for $project_dir"
#!/bin/bash
# setup-email-templates.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

log "Setting up email templates for $project_dir"

mkdir -p "$project_dir/server/src/services"
mkdir -p "$project_dir/server/src/models"
mkdir -p "$project_dir/server/src/routes"

cd "$project_dir/server" || error_exit "Failed to change to server directory"
npm install nodemailer handlebars


# Create EmailService
cat << EOF > "$project_dir/server/src/services/emailService.js"
const nodemailer = require('nodemailer');
const handlebars = require('handlebars');
const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

class EmailService {
  constructor() {
    this.transporter = nodemailer.createTransport({
      host: process.env.SMTP_HOST,
      port: process.env.SMTP_PORT,
      auth: {
        user: process.env.SMTP_USER,
        pass: process.env.SMTP_PASS
      }
    });
  }

  async sendEmail(to, subject, template, context) {
    const compiledTemplate = handlebars.compile(template);
    const html = compiledTemplate(context);

    const mailOptions = {
      from: process.env.EMAIL_FROM,
      to,
      subject,
      html
    };

    await this.transporter.sendMail(mailOptions);
  }

  async saveTemplate(templateData) {
    const query = 'INSERT INTO email_templates(name, subject, body) VALUES(\$1, \$2, \$3) RETURNING *';
    const values = [templateData.name, templateData.subject, templateData.body];
    const result = await pool.query(query, values);
    return result.rows[0];
  }

  async getTemplates() {
    const result = await pool.query('SELECT * FROM email_templates');
    return result.rows;
  }

  async getTemplateByName(name) {
    const result = await pool.query('SELECT * FROM email_templates WHERE name = \$1', [name]);
    return result.rows[0];
  }
}

module.exports = new EmailService();
EOF

# Create EmailTemplate model
cat << EOF > "$project_dir/server/src/models/EmailTemplate.js"
const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

class EmailTemplateModel {
  async saveTemplate(templateData) {
    const query = 'INSERT INTO email_templates(name, subject, body) VALUES(\$1, \$2, \$3) RETURNING *';
    const values = [templateData.name, templateData.subject, templateData.body];
    const result = await pool.query(query, values);
    return result.rows[0];
  }

  async getTemplates() {
    const result = await pool.query('SELECT * FROM email_templates');
    return result.rows;
  }

  async getTemplateByName(name) {
    const result = await pool.query('SELECT * FROM email_templates WHERE name = \$1', [name]);
    return result.rows[0];
  }
}

module.exports = new EmailTemplateModel();
EOF

# Create email template routes
cat << EOF > "$project_dir/server/src/routes/emailTemplateRoutes.js"
const express = require('express');
const EmailService = require('../services/emailService');
const router = express.Router();

router.post('/', async (req, res) => {
  try {
    const template = await EmailService.saveTemplate(req.body);
    res.status(201).json(template);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

router.get('/', async (req, res) => {
  try {
    const templates = await EmailService.getTemplates();
    res.json(templates);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/send', async (req, res) => {
  try {
    const { templateName, to, context } = req.body;
    const template = await EmailService.getTemplateByName(templateName);
    if (!template) {
      return res.status(404).json({ message: 'Template not found' });
    }
    await EmailService.sendEmail(to, template.subject, template.body, context);
    res.json({ message: 'Email sent successfully' });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
EOF

log "Email templates setup completed for $project_dir"
#!/bin/bash
# setup-file-management.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

log "Setting up file management for $project_dir"

mkdir -p "$project_dir/server/src/services"
mkdir -p "$project_dir/server/src/routes"
mkdir -p "$project_dir/server/src/models"

cd "$project_dir/server" || error_exit "Failed to change to server directory"
npm install multer aws-sdk

# Create FileService
cat << EOF > "$project_dir/server/src/services/fileService.js"
const aws = require('aws-sdk');
const multer = require('multer');
const multerS3 = require('multer-s3');
const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

aws.config.update({
  secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
  accessKeyId: process.env.AWS_ACCESS_KEY_ID,
  region: process.env.AWS_REGION
});

const s3 = new aws.S3();

const upload = multer({
  storage: multerS3({
    s3: s3,
    bucket: process.env.S3_BUCKET,
    acl: 'public-read',
    metadata: function (req, file, cb) {
      cb(null, {fieldName: file.fieldname});
    },
    key: function (req, file, cb) {
      cb(null, Date.now().toString() + '-' + file.originalname)
    }
  })
});

class FileService {
  async saveFile(fileData) {
    const query = 'INSERT INTO files(filename, originalname, mimetype, size, url, uploadedby) VALUES(\$1, \$2, \$3, \$4, \$5, \$6) RETURNING *';
    const values = [fileData.filename, fileData.originalname, fileData.mimetype, fileData.size, fileData.url, fileData.uploadedby];
    const result = await pool.query(query, values);
    return result.rows[0];
  }

  async getFilesByUser(userId) {
    const query = 'SELECT * FROM files WHERE uploadedby = \$1';
    const result = await pool.query(query, [userId]);
    return result.rows;
  }
}

module.exports = { upload, FileService: new FileService() };
EOF

# Create File model
cat << EOF > "$project_dir/server/src/models/File.js"
const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

class FileModel {
  async saveFile(fileData) {
    const query = 'INSERT INTO files(filename, originalname, mimetype, size, url, uploadedby) VALUES(\$1, \$2, \$3, \$4, \$5, \$6) RETURNING *';
    const values = [fileData.filename, fileData.originalname, fileData.mimetype, fileData.size, fileData.url, fileData.uploadedby];
    const result = await pool.query(query, values);
    return result.rows[0];
  }

  async getFilesByUser(userId) {
    const query = 'SELECT * FROM files WHERE uploadedby = \$1';
    const result = await pool.query(query, [userId]);
    return result.rows;
  }
}

module.exports = new FileModel();
EOF

# Create file routes
cat << EOF > "$project_dir/server/src/routes/fileRoutes.js"
const express = require('express');
const { upload, FileService } = require('../services/fileService');
const router = express.Router();

router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const fileData = {
      filename: req.file.key,
      originalname: req.file.originalname,
      mimetype: req.file.mimetype,
      size: req.file.size,
      url: req.file.location,
      uploadedby: req.user.id
    };
    const file = await FileService.saveFile(fileData);
    res.status(201).json(file);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

router.get('/', async (req, res) => {
  try {
    const files = await FileService.getFilesByUser(req.user.id);
    res.json(files);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
EOF

log "File management setup completed for $project_dir"
#!/bin/bash
# setup-i18n.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

client_dir="$project_dir/client"
cd "$client_dir" || error_exit "Failed to change to client directory"

log "Setting up internationalization for $client_dir"

# Install react-i18next, i18next, and related packages
npm install react-i18next i18next i18next-http-backend i18next-browser-languagedetector

# Create i18n configuration
mkdir -p src/i18n
cat << EOF > src/i18n/i18n.js
import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import Backend from 'i18next-http-backend';
import LanguageDetector from 'i18next-browser-languagedetector';

i18n
  .use(Backend)
  .use(LanguageDetector)
  .use(initReactI18next)
  .init({
    fallbackLng: 'en',
    debug: process.env.NODE_ENV !== 'production',
    interpolation: {
      escapeValue: false,
    },
    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json',
    },
  });

export default i18n;
EOF

# Create sample translation files
mkdir -p public/locales/en public/locales/es
echo '{"hello": "Hello", "welcome": "Welcome to our app!"}' > public/locales/en/translation.json
echo '{"hello": "Hola", "welcome": "Bienvenido a nuestra aplicacin!"}' > public/locales/es/translation.json

# Update index.js to use i18n
sed -i '1iimport "./i18n/i18n";\n' src/index.js

# Create a language switcher component
cat << EOF > src/components/LanguageSwitcher.js
import React from 'react';
import { useTranslation } from 'react-i18next';

const LanguageSwitcher = () => {
  const { i18n } = useTranslation();

  const changeLanguage = (lng) => {
    i18n.changeLanguage(lng);
  };

  return (
    <div>
      <button onClick={() => changeLanguage('en')}>English</button>
      <button onClick={() => changeLanguage('es')}>Espaol</button>
    </div>
  );
};

export default LanguageSwitcher;
EOF

log "Internationalization setup completed for $client_dir directory."
#!/bin/bash
# setup-noloco-theme.sh

project_dir="$1"
install_target="$2"

if [ -z "$project_dir" ] || [ -z "$install_target" ]; then
    echo "Usage: $0 <project-dir> <install-target>"
    echo "install-target options: client, server, both"
    exit 1
fi

# Colors
PRIMARY_COLOR="#0F172A"
SECONDARY_COLOR="#3B82F6"
BACKGROUND_COLOR="#F8FAFC"
TEXT_COLOR="#1E293B"

# Font
FONT_FAMILY="'Inter', sans-serif"

setup_client() {
    echo "Setting up Noloco theme for client..."

    # Install dependencies
    cd "$project_dir/client" || exit
    npm install styled-components@^5.3.5 react-icons@^4.3.1

    # Create theme file
    mkdir -p src/styles
    cat << EOF > src/styles/NolocoTheme.js
import { createGlobalStyle } from 'styled-components';

const NolocoTheme = {
  colors: {
    primary: '${PRIMARY_COLOR}',
    secondary: '${SECONDARY_COLOR}',
    background: '${BACKGROUND_COLOR}',
    text: '${TEXT_COLOR}',
  },
  fonts: {
    body: ${FONT_FAMILY},
  },
};
export default NolocoTheme;

export const GlobalStyle = createGlobalStyle\`
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

  body {
    font-family: ${FONT_FAMILY};
    background-color: ${BACKGROUND_COLOR};
    color: ${TEXT_COLOR};
    margin: 0;
    padding: 0;
  }

  h1, h2, h3, h4, h5, h6 {
    color: ${PRIMARY_COLOR};
  }

  a {
    color: ${SECONDARY_COLOR};
    text-decoration: none;
  }
\`;
EOF

    # Create component templates
    mkdir -p src/components/Noloco

    # Button component
    cat << EOF > src/components/Noloco/Button.js
import styled from 'styled-components';

const Button = styled.button\`
  background-color: \${props => props.theme.colors.secondary};
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 4px;
  font-weight: 600;
  cursor: pointer;
  transition: background-color 0.3s ease;

  &:hover {
    background-color: \${props => props.theme.colors.primary};
  }
\`;

export default Button;
EOF

    # Card component
    cat << EOF > src/components/Noloco/Card.js
import styled from 'styled-components';

const Card = styled.div\`
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  padding: 20px;
  margin-bottom: 20px;
\`;

export default Card;
EOF

    # Container component
    cat << EOF > src/components/Noloco/Container.js
import styled from 'styled-components';

const Container = styled.div\`
  max-width: 1200px;
  margin: 0 auto;
  padding: 0 20px;
\`;

export default Container;
EOF

    # Update App.js to use the theme
    sed -i "1i import { ThemeProvider } from 'styled-components';" src/App.js
    sed -i "2i import { theme, GlobalStyle } from './styles/NolocoTheme';" src/App.js
    sed -i "s/<React.StrictMode>/<ThemeProvider theme={theme}><React.StrictMode><GlobalStyle \/>/" src/App.js
    sed -i "s/<\/React.StrictMode>/<\/React.StrictMode><\/ThemeProvider>/" src/App.js

    echo "Client Noloco theme setup completed."
}

setup_server() {
    echo "Setting up Noloco theme for server..."

    # For server, we'll create some utility functions and middleware that align with Noloco's style
    cd "$project_dir/server" || exit
    mkdir -p src/utils src/middleware

    # Create a utility file for consistent API responses
    cat << EOF > src/utils/apiResponse.js
const sendResponse = (res, statusCode, data, message = '') => {
  res.status(statusCode).json({
    success: statusCode < 400,
    data,
    message,
  });
};

const sendError = (res, statusCode, message) => {
  res.status(statusCode).json({
    success: false,
    error: message,
  });
};

module.exports = {
  sendResponse,
  sendError,
};
EOF

    # Create a middleware for error handling
    cat << EOF > src/middleware/errorHandler.js
const { sendError } = require('../utils/apiResponse');

const errorHandler = (err, req, res, next) => {
  console.error(err.stack);

  const statusCode = err.statusCode || 500;
  const message = err.message || 'Internal Server Error';

  sendError(res, statusCode, message);
};

module.exports = errorHandler;
EOF

    echo "Server-side Noloco theme setup completed."
}

case "$install_target" in
    client)
        setup_client
        ;;
    server)
        setup_server
        ;;
    both)
        setup_client
        setup_server
        ;;
    *)
        echo "Invalid install target. Choose 'client', 'server', or 'both'."
        exit 1
        ;;
esac

echo "Noloco theme setup completed for $install_target."
#!/bin/bash
# setup-performance-optimization.sh

set -euo pipefail

project_dir="$1"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir>"
  exit 1
fi

client_dir="$project_dir/client"
cd "$client_dir" || exit 1

# Add a utility for image optimization
mkdir -p src/utils
cat << EOF > src/utils/imageOptimization.js
export const getOptimizedImageUrl = (url, width, height) => {
  // This is a placeholder. In a real-world scenario, you'd integrate with
  // an image optimization service like Cloudinary or Imgix.
  return `${url}?w=${width}&h=${height}&fit=crop&auto=format`;
};
EOF

# Add a custom hook for intersection observer (for lazy loading)
cat << EOF > src/utils/useIntersectionObserver.js
import { useState, useEffect } from 'react';

const useIntersectionObserver = (ref, options = {}) => {
  const [isIntersecting, setIsIntersecting] = useState(false);

  useEffect(() => {
    const observer = new IntersectionObserver(([entry]) => {
      setIsIntersecting(entry.isIntersecting);
    }, options);

    if (ref.current) {
      observer.observe(ref.current);
    }

    return () => {
      observer.disconnect();
    };
  }, [ref, options]);

  return isIntersecting;
};

export default useIntersectionObserver;
EOF

echo "Enhanced performance optimization setup completed for $client_dir"
#!/bin/bash
# setup-postgresql.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_name="$1"
db_user="$2"
db_pass="$3"

if [ -z "$project_name" ] || [ -z "$db_user" ] || [ -z "$db_pass" ]; then
  error_exit "Usage: $0 <project-name> <db-user> <db-pass>"
fi

log "Setting up PostgreSQL for $project_name"

# Check if PostgreSQL is installed
log "Checking if PostgreSQL is installed..."
if ! command -v psql &> /dev/null; then
    error_exit "PostgreSQL is not installed. Please install it and try again."
fi

log "PostgreSQL is installed. Proceeding with setup..."

project_dir="/d/Node/projects/$project_name"
server_dir="$project_dir/server"
cd "$server_dir" || error_exit "Failed to change to server directory"

# Create database and user
log "Attempting to create database and user..."
PGPASSWORD="${db_pass}" psql -U postgres -h localhost << EOF
CREATE DATABASE ${project_name} WITH OWNER ${db_user};
DO
\$\$
BEGIN
  IF NOT EXISTS (SELECT FROM pg_catalog.pg_roles WHERE rolname = '${db_user}') THEN
    CREATE USER ${db_user} WITH ENCRYPTED PASSWORD '${db_pass}';
  END IF;
END
\$\$;
GRANT ALL PRIVILEGES ON DATABASE ${project_name} TO ${db_user};
\c ${project_name}
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
EOF

if [ $? -ne 0 ]; then
    error_exit "Failed to set up database and user"
fi
log "Database and user setup completed."

log "Database and user created successfully."

# Update .env file
log "Updating .env file..."
if [ -f .env ]; then
    sed -i '/^DATABASE_URL/d' .env
fi
echo "DATABASE_URL=postgres://${db_user}:${db_pass}@localhost:5432/${project_name}" >> .env

log ".env file updated."

# Install necessary packages
log "Installing necessary npm packages..."
npm install express pg sequelize dotenv || error_exit "Failed to install npm packages"

log "NPM packages installed."

# Create database connection utility
log "Creating database connection utility..."
mkdir -p "$server_dir/src/config"
cat << EOF > "$server_dir/src/config/database.js"
// src/config/database.js
const { Pool } = require('pg');
const { Sequelize } = require('sequelize');
require('dotenv').config();

const sequelize = new Sequelize(process.env.DATABASE_URL, {
  dialect: 'postgres',
  logging: false,
  pool: {
    max: 5,
    min: 0,
    acquire: 30000,
    idle: 10000
  }
});

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

const testConnection = async () => {
  try {
    await sequelize.authenticate();
    console.log('Sequelize connection has been established successfully.');

    const client = await pool.connect();
    console.log('PostgreSQL pool connection has been established successfully.');
    client.release();
  } catch (error) {
    console.error('Unable to connect to the database:', error);
  }
};

testConnection();

module.exports = {
  sequelize,
  Sequelize,
  query: (text, params) => pool.query(text, params),
};
EOF

log "Database connection utility created."

# Create a basic model
log "Creating basic User model..."
mkdir -p "$server_dir/src/models"
cat << EOF > "$server_dir/src/models/User.js"
// src/models/User.js

const { Sequelize, DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const User = sequelize.define('User', {
  name: {
    type: DataTypes.STRING,
    allowNull: false
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  },
  password: {
    type: DataTypes.STRING,
    allowNull: false
  }
});

module.exports = User;
EOF

log "Basic User model created."

log "PostgreSQL setup completed for $project_name"
#!/bin/bash
# setup-project.sh

set -e

project_name=$1

if [ -z "$project_name" ]; then
  echo "Usage: $0 <project-name>"
  exit 1
fi

# Check for Node.js and npm
if ! command -v node > /dev/null 2>&1 || ! command -v npm > /dev/null 2>&1; then
    error_exit "Node.js and npm are required but not installed. Please install them and try again."
fi

project_dir="/d/Node/projects/$project_name"
client_dir="$project_dir/client"
server_dir="$project_dir/server"

log() {
  echo "$(date +"%Y-%m-%d %T") : $1"
}

error_exit() {
  echo "$(date +"%Y-%m-%d %T") : $1" 1>&2
  exit 1
}

log "Creating project directory..."
mkdir -p "$project_dir" || error_exit "Failed to create project directory"
cd "$project_dir" || error_exit "Failed to navigate to project directory"
touch .gitignore README.md || error_exit "Failed to create initial config files"
mkdir -p .github docs || error_exit "Failed to create project structure directories"

# Initialize project structure
log "Initializing project structure..."
mkdir -p "$server_dir/src/config" "$server_dir/src/controllers" "$server_dir/src/middleware" "$server_dir/src/models" "$server_dir/src/routes" "$server_dir/src/utils" "$server_dir/src/services" || error_exit "Failed to create server structure directories"
mkdir -p "$server_dir/tests" || error_exit "Failed to create tests directory"
cd "$server_dir" || error_exit "Failed to navigate to server directory"
touch "$server_dir/package.json" "$server_dir/src/app.js" "$server_dir/.env" "$server_dir/babel.config.js" "$server_dir/jest.config.js" "$server_dir/jest.setup.js" || error_exit "Failed to create initial server files"

cat << EOF > "$server_dir/package.json"
{
  "name": "${project_name}",
  "version": "1.0.0",
  "main": "index.js",
  "directories": {
    "doc": "docs"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": ""
}
EOF

log "Installing express pg sequelize cors dotenv dependencies..."
npm install express pg sequelize cors dotenv

log "Creating server/src/app.js..."
cat << EOF > "$server_dir/src/app.js"
const express = require('express');
const { Pool } = require('pg');
const session = require('express-session');
const pgSession = require('connect-pg-simple')(session);
const passport = require('passport');
const cors = require('cors');
const dotenv = require('dotenv');
const path = require('path');
const errorHandler = require('./middleware/error-handling-middleware');

dotenv.config();

const app = express();

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// PostgreSQL Pool
const pool = new Pool({
    connectionString: process.env.DATABASE_URL
});

// Session Management
app.use(session({
    store: new pgSession({
        pool: pool,
        tableName: 'session'
    }),
    secret: process.env.SESSION_SECRET || 'your_secret_key',
    resave: false,
    saveUninitialized: false,
    cookie: { secure: process.env.NODE_ENV === 'production' }
}));

// Passport middleware
app.use(passport.initialize());
app.use(passport.session());

// Passport Config
require('./config/passport')(passport);

// Routes
app.use('/api/models', require('./routes/models'));
// Add other routes as needed

// Serve static files from the React app in production
if (process.env.NODE_ENV === 'production') {
    app.use(express.static(path.join(__dirname, '../../client/build')));

    app.get('*', (req, res) => {
        res.sendFile(path.join(__dirname, '../../client/build', 'index.html'));
    });
}

// Error Handling Middleware
app.use(errorHandler);

module.exports = app;
EOF

log "Updating package.json with new dependencies..."
cd "$server_dir"
npm install express-session connect-pg-simple passport
npm install --save-dev @types/express-session @types/passport
cd -

log "Creating error handling middleware..."
mkdir -p "$server_dir/src/middleware"

cat << EOF > "$server_dir/src/middleware/error-handling-middleware.js"
const errorHandler = (err, req, res, next) => {
    console.error(err.stack);
    res.status(500).send('Something broke!');
};

module.exports = errorHandler;
EOF

log "Creating basic passport configuration..."
mkdir -p "$server_dir/src/config"
cat << EOF > "$server_dir/src/config/passport.js"
module.exports = (passport) => {
    // Add passport strategies and serialization here
    // This is a placeholder and should be expanded based on your auth requirements
};
EOF

log "Creating server/src/routes/models.js..."
cat << EOF > src/routes/models.js
const express = require('express');
const router = express.Router();
const DataModelingService = require('../services/dataModelingService');

router.post('/models', async (req, res, next) => {
  try {
    const { name, fields } = req.body;
    await DataModelingService.saveModel({ name, fields });
    res.status(201).json({ message: 'Model saved successfully' });
  } catch (error) {
    next(error);
  }
});

router.get('/models', async (req, res, next) => {
  try {
    const models = await DataModelingService.getModels();
    res.json(models);
  } catch (error) {
    next(error);
  }
});

module.exports = router;
EOF

log "Creating server/src/index.js..."
cat << EOF > "$server_dir/src/index.js"
const express = require('express');
const cors = require('cors');
require('dotenv').config();
const { sequelize } = require('./utils/db');
const modelRoutes = require('./routes/models');
const dynamicApiRoutes = require('./routes/dynamicApiRoutes');

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());

// Routes
app.use('/api/models', modelRoutes);
app.use('/api', dynamicApiRoutes);

app.get('/', (req, res) => {
  res.json({ message: 'Welcome to the API' });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});

// Database connection and server start
const startServer = async () => {
  try {
    await sequelize.authenticate();
    console.log('Database connection has been established successfully.');

    app.listen(PORT, () => console.log(`Server running on port ${PORT}`));
  } catch (error) {
    console.error('Unable to connect to the database:', error);
  }
};

startServer();
EOF

log "Creating server/.env..."
cat << EOF > "$server_dir/.env"
DATABASE_URL=postgres://${project_name}_user:your_secure_password@localhost:5432/${project_name}
PORT=3000
BASE_URL=http://localhost:3000  # Optional, for local development
EOF

log "Creating project .gitignore..."
cat << EOF > "$project_dir/.gitignore"
node_modules/
.env
*.log
build/
EOF

log "Updating server/src/index.js to use app.js..."
sed -i '1i\const app = require(\'./app');' "$server_dir/src/index.js"
sed -i '/const app = express();/d' "$server_dir/src/index.js"
sed -i '/app\.use(cors());/d' "$server_dir/src/index.js"
sed -i '/app\.use(express\.json());/d' "$server_dir/src/index.js"

log "Setting up client..."
npx create-react-app "$client_dir"
cd "$client_dir" || error_exit "Failed to navigate to client directory"
npm install axios react-router-dom styled-components

log "Project $project_name set up successfully"
#!/bin/bash
# setup-pwa.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

client_dir="$project_dir/client"
cd "$client_dir" || error_exit "Failed to change to client directory"

log "Setting up PWA for $client_dir"

# Install workbox-webpack-plugin and other PWA-related packages
npm install --save-dev workbox-webpack-plugin
npm install workbox-window

# Update webpack.config.js to include workbox plugin
cat << EOF >> webpack.config.js

const WorkboxWebpackPlugin = require('workbox-webpack-plugin');

module.exports.plugins.push(
  new WorkboxWebpackPlugin.GenerateSW({
    clientsClaim: true,
    skipWaiting: true,
    runtimeCaching: [{
      urlPattern: /^https?.*/,
      handler: 'NetworkFirst',
      options: {
        cacheName: 'https-calls',
        networkTimeoutSeconds: 15,
        expiration: {
          maxEntries: 150,
          maxAgeSeconds: 30 * 24 * 60 * 60, // 1 month
        },
        cacheableResponse: {
          statuses: [0, 200],
        },
      },
    }],
  })
);
EOF

# Create a manifest.json file
cat << EOF > public/manifest.json
{
  "short_name": "Your App",
  "name": "Your Application Name",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}
EOF

# Update index.html to include manifest and theme-color
sed -i '/<\/head>/i\    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />' public/index.html
sed -i '/<\/head>/i\    <meta name="theme-color" content="#000000" />' public/index.html

# Create a service worker registration file
cat << EOF > src/serviceWorkerRegistration.js
import { Workbox } from 'workbox-window';

export function register() {
  if ('serviceWorker' in navigator) {
    const wb = new Workbox('/service-worker.js');

    wb.addEventListener('installed', event => {
      if (event.isUpdate) {
        if (confirm('New content is available! Click OK to refresh.')) {
          window.location.reload();
        }
      }
    });

    wb.register();
  }
}
EOF

# Update index.js to include service worker registration
cat << EOF >> src/index.js

import { register } from './serviceWorkerRegistration';

register();
EOF

log "PWA setup completed for $client_dir directory."
#!/bin/bash
# setup-rbac.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

server_dir="$project_dir/server"
src_dir="$server_dir/src"

mkdir -p "$src_dir/middlewares" "$src_dir/models" "$src_dir/routes"

log "Setting up RBAC for $project_dir"

# Install required packages
cd "$server_dir"
npm install bcryptjs jsonwebtoken
cd -

# Create RBAC middleware
cat << EOF > "$src_dir/middlewares/rbacMiddleware.js"
// src/middlewares/rbacMiddleware.js
const rbacMiddleware = (requiredRole) => {
  return (req, res, next) => {
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: 'Access denied' });
    }

    if (req.user.role !== requiredRole) {
      return res.status(403).json({ message: 'Insufficient permissions' });
    }

    next();
  };
};

module.exports = rbacMiddleware;
EOF

# Create User model with role
cat << EOF > "$src_dir/models/User.js"
const { Pool } = require('pg');
const bcrypt = require('bcryptjs');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

class UserService {
  async createUser(userData) {
    const hashedPassword = await bcrypt.hash(userData.password, 12);
    const query = 'INSERT INTO users (username, email, password, role) VALUES(\$1, \$2, \$3, \$4) RETURNING *';
    const values = [userData.username, userData.email, hashedPassword, userData.role];
    const result = await pool.query(query, values);
    return result.rows[0];
  }

  async findUserByEmail(email) {
    const query = 'SELECT * FROM users WHERE email = \$1';
    const result = await pool.query(query, [email]);
    return result.rows[0];
  }

  async comparePassword(candidatePassword, storedPassword) {
    return bcrypt.compare(candidatePassword, storedPassword);
  }
}

module.exports = new UserService();
EOF

# Update auth routes to include role
cat << EOF > "$src_dir/routes/authRoutes.js"
// src/routes/authRoutes.js
const express = require('express');
const jwt = require('jsonwebtoken');
const UserService = require('../models/User');
const rbacMiddleware = require('../middlewares/rbacMiddleware');

const router = express.Router();

router.post('/register', async (req, res) => {
  try {
    const { username, email, password, role } = req.body;
    const user = await UserService.createUser({ username, email, password, role });
    res.status(201).json({ message: 'User registered successfully', user });
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

router.post('/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    const user = await UserService.findUserByEmail(email);
    if (!user || !(await UserService.comparePassword(password, user.password))) {
      return res.status(401).json({ message: 'Invalid credentials' });
    }
    const token = jwt.sign({ userId: user.id, role: user.role }, process.env.JWT_SECRET, { expiresIn: '1d' });
    res.json({ token });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Example of a protected route using RBAC
router.get('/admin-only', rbacMiddleware('admin'), (req, res) => {
  res.json({ message: 'Welcome, admin!' });
});

module.exports = router;
EOF

log "RBAC setup completed for $project_dir"
#!/bin/bash
# setup-redux.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir>"
  exit 1
fi

if ! command -v npm &> /dev/null; then
  error_exit "npm could not be found, please install Node.js and npm first."
fi

client_dir="$project_dir/client"
src_dir="$client_dir/src"

cd "$client_dir"

log "Installing Redux and related packages..."
npm install redux react-redux @reduxjs/toolkit

log "Creating Redux directory structure..."
mkdir -p "$src_dir/redux/slices"

log "Creating store.js..."
cat << EOF > "$src_dir/redux/store.js"
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './slices';

const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production',
});

export default store;
EOF

log "Creating root reducer (index.js in slices directory)..."
cat << EOF > "$src_dir/redux/slices/index.js"
import { combineReducers } from 'redux';
import exampleSlice from './exampleSlice';

const rootReducer = combineReducers({
  example: exampleSlice,
});

export default rootReducer;
EOF

log "Creating an example slice..."
cat << EOF > "$src_dir/redux/slices/exampleSlice.js"
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  value: 0,
};

const exampleSlice = createSlice({
  name: 'example',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = exampleSlice.actions;
export default exampleSlice.reducer;
EOF

log "Updating index.js to use Redux..."
sed -i "1i import { Provider } from 'react-redux';" "$src_dir/index.js"
sed -i "2i import store from './redux/store';" "$src_dir/index.js"
sed -i "s/<React.StrictMode>/<Provider store={store}><React.StrictMode>/" "$src_dir/index.js"
sed -i "s/<\/React.StrictMode>/<\/React.StrictMode><\/Provider>/" "$src_dir/index.js"

log "Updating App.js to remove redundant Redux provider..."
cat << EOF > "$src_dir/App.js"
import React from 'react';

const App = () => {
  return (
    <div>
      {/* Your app content here */}
    </div>
  );
};

export default App;
EOF

log "Updating index.js to use Redux..."
index_file="$src_dir/index.js"
temp_file=$(mktemp)

cat << EOF > "$temp_file"
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import store from './redux/store';
import App from './App';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);
EOF

mv "$temp_file" "$index_file"

log "Redux setup completed for $client_dir directory."
#!/bin/bash
# setup-redux.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir>"
  exit 1
fi

if ! command -v npm &> /dev/null; then
  error_exit "npm could not be found, please install Node.js and npm first."
fi

client_dir="$project_dir/client"
src_dir="$client_dir/src"

cd "$client_dir"

log "Installing Redux and related packages..."
npm install redux react-redux @reduxjs/toolkit

log "Creating Redux directory structure..."
mkdir -p "$src_dir/redux/slices"

log "Creating store.js..."
cat << EOF > "$src_dir/redux/store.js"
import { configureStore } from '@reduxjs/toolkit';
import rootReducer from './slices';

const store = configureStore({
  reducer: rootReducer,
  devTools: process.env.NODE_ENV !== 'production',
});

export default store;
EOF

log "Creating root reducer (index.js in slices directory)..."
cat << EOF > "$src_dir/redux/slices/index.js"
import { combineReducers } from 'redux';
import exampleSlice from './exampleSlice';

const rootReducer = combineReducers({
  example: exampleSlice,
});

export default rootReducer;
EOF

log "Creating an example slice..."
cat << EOF > "$src_dir/redux/slices/exampleSlice.js"
import { createSlice } from '@reduxjs/toolkit';

const initialState = {
  value: 0,
};

const exampleSlice = createSlice({
  name: 'example',
  initialState,
  reducers: {
    increment: (state) => {
      state.value += 1;
    },
    decrement: (state) => {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = exampleSlice.actions;
export default exampleSlice.reducer;
EOF

log "Updating index.js to use Redux..."
sed -i "1i import { Provider } from 'react-redux';" "$src_dir/index.js"
sed -i "2i import store from './redux/store';" "$src_dir/index.js"
sed -i "s/<React.StrictMode>/<Provider store={store}><React.StrictMode>/" "$src_dir/index.js"
sed -i "s/<\/React.StrictMode>/<\/React.StrictMode><\/Provider>/" "$src_dir/index.js"

log "Updating App.js to use Redux..."
cat << EOF > "$src_dir/App.js"
import React from 'react';

const App = () => {
  return (
    <div>
      {/* Your app content here */}
    </div>
  );
};

export default App;
EOF

log "Updating index.js to use Redux..."
index_file="$src_dir/index.js"
temp_file=$(mktemp)

cat << EOF > "$temp_file"
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import store from './redux/store';
import App from './App';
import './index.css';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <Provider store={store}>
      <App />
    </Provider>
  </React.StrictMode>
);
EOF

mv "$temp_file" "$index_file"

log "Redux setup completed for $client_dir directory."
#!/bin/bash
# setup-responsive-design.sh

project_dir="$1"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir>"
  exit 1
fi

client_dir="$project_dir/client"
cd "$client_dir"
mkdir -p src/styles
mkdir -p src/components

cat << EOF > src/styles/breakpoints.js
const sizes = {
  mobile: '576px',
  tablet: '768px',
  desktop: '1024px',
  largeDesktop: '1440px',
};

export const devices = {
  mobile: \`(min-width: \${sizes.mobile})\`,
  tablet: \`(min-width: \${sizes.tablet})\`,
  desktop: \`(min-width: \${sizes.desktop})\`,
  largeDesktop: \`(min-width: \${sizes.largeDesktop})\`,
};

export const mediaQueries = {
  mobile: \`@media \${devices.mobile}\`,
  tablet: \`@media \${devices.tablet}\`,
  desktop: \`@media \${devices.desktop}\`,
  largeDesktop: \`@media \${devices.largeDesktop}\`,
};
EOF

cat << EOF > src/styles/ResponsiveWrapper.js
import styled from 'styled-components';
import { mediaQueries } from './breakpoints';

const ResponsiveWrapper = styled.div\`
  padding: 1rem;
  width: 100%;
  max-width: 100%;

  \${mediaQueries.tablet} {
    padding: 2rem;
    max-width: 720px;
    margin: 0 auto;
  }

  \${mediaQueries.desktop} {
    padding: 3rem;
    max-width: 960px;
  }

  \${mediaQueries.largeDesktop} {
    max-width: 1200px;
  }
\`;

export default ResponsiveWrapper;
EOF

# Create a responsive grid component
cat << EOF > src/components/ResponsiveGrid.js
import styled from 'styled-components';
import { mediaQueries } from '../styles/breakpoints';

const ResponsiveGrid = styled.div\`
  display: grid;
  grid-template-columns: 1fr;
  gap: 1rem;

  \${mediaQueries.tablet} {
    grid-template-columns: repeat(2, 1fr);
  }

  \${mediaQueries.desktop} {
    grid-template-columns: repeat(3, 1fr);
  }

  \${mediaQueries.largeDesktop} {
    grid-template-columns: repeat(4, 1fr);
  }
\`;

export default ResponsiveGrid;
EOF

echo "Responsive design helpers created in $client_dir/src/styles and $client_dir/src/components"
#!/bin/bash
# setup-sass.sh

project_dir="$1"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir>"
  exit 1
fi

client_dir="$project_dir/client"
cd "$client_dir"

# Install SASS
npm install sass

# Create SASS directory structure
mkdir -p src/styles/abstracts src/styles/base src/styles/components src/styles/layout src/styles/pages

# Create main SASS file
cat << EOF > src/styles/main.scss
@import 'abstracts/variables';
@import 'abstracts/mixins';

@import 'base/reset';
@import 'base/typography';

@import 'components/buttons';
@import 'components/forms';

@import 'layout/header';
@import 'layout/footer';

@import 'pages/home';
EOF

# Create example files
cat << EOF > src/styles/abstracts/_variables.scss
\$primary-color: #0070f3;
\$secondary-color: #0070f3;
\$font-stack: Arial, sans-serif;
EOF

cat << EOF > src/styles/abstracts/_mixins.scss
@mixin flexCenter {
  display: flex;
  justify-content: center;
  align-items: center;
}
EOF

cat << EOF > src/styles/base/_reset.scss
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
EOF

# Update package.json scripts
npm pkg set scripts.sass="sass src/styles/main.scss src/styles/main.css"
npm pkg set scripts.sass:watch="sass src/styles/main.scss src/styles/main.css --watch"

echo "SASS setup completed for $client_dir directory."
#!/bin/bash
# setup-seo.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}

project_dir="$1"
client_dir="$project_dir/client"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

cd "$client_dir" || error_exit "Failed to change to client directory"

log "Setting up SEO for $client_dir"

# Install react-helmet for managing document head
npm install react-helmet-async

# Create SEO component
cat << EOF > src/components/SEO.js
import React from 'react';
import { Helmet } from 'react-helmet-async';

const SEO = ({ title, description, keywords, image, url }) => (
  <Helmet>
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="keywords" content={keywords} />
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:image" content={image} />
    <meta property="og:url" content={url} />
    <meta property="og:type" content="website" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={image} />
    <link rel="canonical" href={url} />
  </Helmet>
);

export default SEO;
EOF

mkdir -p "$client_dir/scripts"
cd "$client_dir"

# Create the sitemap generator JavaScript file
cat << 'EOF' > "$client_dir/scripts/generate-sitemap.js"
const fs = require('fs');
const path = require('path');
require('dotenv').config({ path: path.join(__dirname, '../../.env') });

const baseUrl = process.env.BASE_URL || `http://localhost:${process.env.PORT || 3000}`;
const publicDir = path.join(__dirname, '../public');

const getPages = () => {
  // This is a simplified example. In reality, you'd want to
  // generate this list based on your actual routes.
  return ['', 'register'];
};

const generateSitemap = () => {
  const pages = getPages();
  const sitemap = `<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  ${pages.map(page => `
  <url>
    <loc>${baseUrl}/${page}</loc>
    <lastmod>${new Date().toISOString().split('T')[0]}</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>
  `).join('')}
</urlset>`;

  fs.writeFileSync(path.join(publicDir, 'sitemap.xml'), sitemap);
  console.log('Sitemap generated successfully');

  // Generate robots.txt
  const robotsTxt = `User-agent: *
Allow: /

Sitemap: ${baseUrl}/sitemap.xml
`;
  fs.writeFileSync(path.join(publicDir, 'robots.txt'), robotsTxt);
  console.log('robots.txt generated successfully');
};

generateSitemap();
EOF

# Run the sitemap generator
node "$client_dir/scripts/generate-sitemap.js"

# Add sitemap generation script to package.json
npm pkg set scripts.generate-sitemap="node scripts/generate-sitemap.js"

log "SEO setup completed for $project_dir"
#!/bin/bash
# setup-state-management.sh

set -euo pipefail

project_dir="$1"
state_management="${2:-redux}"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir> [state-management]"
  echo "State management options: redux (default), mobx"
  exit 1
fi

client_dir="$project_dir/client"
cd "$client_dir" || exit 1

echo "Setting up $state_management for $client_dir"

case "$state_management" in
  redux)
    # Redux setup (as before)
    ;;
  mobx)
    # MobX setup (as before)
    ;;
  *)
    echo "Invalid state management type. Choose 'redux' or 'mobx'."
    exit 1
    ;;
esac

echo "$state_management setup completed for $client_dir"
#!/bin/bash
# setup-styled-components.sh

project_dir="$1"

if [ -z "$project_dir" ]; then
  echo "Usage: $0 <project-dir>"
  exit 1
fi

client_dir="$project_dir/client"
cd "$client_dir"

# Install styled-components
npm install styled-components

# Create theme file
mkdir -p src/styles

cat << EOF > src/styles/theme.js
export const theme = {
  colors: {
    primary: '#0070f3',
    secondary: '#0070f3',
    background: '#ffffff',
    text: '#000000',
  },
  fonts: {
    body: 'Arial, sans-serif',
    heading: 'Georgia, serif',
  },
  breakpoints: {
    mobile: '576px',
    tablet: '768px',
    desktop: '1024px',
  },
};
EOF

# Create global styles
cat << EOF > src/styles/GlobalStyle.js
import { createGlobalStyle } from 'styled-components';

const GlobalStyle = createGlobalStyle\`
  body {
    margin: 0;
    padding: 0;
    font-family: \${({ theme }) => theme.fonts.body};
    background-color: \${({ theme }) => theme.colors.background};
    color: \${({ theme }) => theme.colors.text};
  }
\`;

export default GlobalStyle;
EOF

# Update App.js to use ThemeProvider and GlobalStyle
sed -i '1s/^/import { ThemeProvider } from "styled-components";\nimport { theme } from "./styles/theme";\nimport GlobalStyle from "./styles/GlobalStyle";\n/' "src/App.js"
sed -i 's/<React.StrictMode>/<ThemeProvider theme={theme}><GlobalStyle \/><React.StrictMode>/; s/<\/React.StrictMode>/<\/React.StrictMode><\/ThemeProvider>/' "src/App.js"

echo "Styled-components setup completed for $client_dir directory."
#!/bin/bash
# setup-workflows.sh

set -euo pipefail

log() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1"
}

error_exit() {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - ERROR: $1" >&2
  exit 1
}


project_dir="$1"

if [ -z "$project_dir" ]; then
  error_exit "Usage: $0 <project-dir>"
fi

mkdir -p "$project_dir/server/src/services" "$project_dir/server/src/models" "$project_dir/server/src/routes"

log "Setting up workflows for $project_dir"

# Create Workflow service
cat << EOF > "$project_dir/server/src/services/workflowService.js"
// src/services/workflowService.js
const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});
const axios = require('axios');

class WorkflowService {
  async executeWorkflow(workflowDefinition, triggerData) {
    let currentData = triggerData;

    for (const step of workflowDefinition.steps) {
      currentData = await this.executeStep(step, currentData);
    }

    return currentData;
  }

  async executeStep(step, data) {
    switch (step.type) {
      case 'transform':
        return this.transformData(step.transformation, data);
      case 'apiCall':
        return this.makeAPICall(step.apiDetails, data);
      case 'condition':
        return this.evaluateCondition(step.condition, data) ? data : null;
      default:
        throw new Error(\`Unknown step type: \${step.type}\`);
    }
  }

  transformData(transformation, data) {
    const result = {};
    for (const [key, value] of Object.entries(transformation)) {
      result[key] = value.split('.').reduce((o, i) => o[i], data);
    }
    return result;
  }

  async makeAPICall(apiDetails, data) {
    const { url, method, body } = apiDetails;
    const response = await axios({ method, url, data: body });
    return response.data;
  }

  evaluateCondition(condition, data) {
    const { left, operator, right } = condition;
    const leftValue = left.split('.').reduce((o, i) => o[i], data);
    switch (operator) {
      case '==':
        return leftValue == right;
      case '!=':
        return leftValue != right;
      case '>':
        return leftValue > right;
      case '<':
        return leftValue < right;
      default:
        throw new Error(\`Unknown operator: \${operator}\`);
    }
  }
}

module.exports = new WorkflowService();
EOF

# Create Workflow model
cat << EOF > "$project_dir/server/src/models/Workflow.js"
// src/models/Workflow.js
const { Pool } = require('pg');
const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

class WorkflowModel {
  async createWorkflow(workflowData) {
    const query = 'INSERT INTO workflows(name, description, trigger, steps) VALUES(\$1, \$2, \$3, \$4) RETURNING *';
    const values = [workflowData.name, workflowData.description, workflowData.trigger, JSON.stringify(workflowData.steps)];
    const result = await pool.query(query, values);
    return result.rows[0];
  }

  async getWorkflows() {
    const result = await pool.query('SELECT * FROM workflows');
    return result.rows;
  }

  async getWorkflowById(id) {
    const result = await pool.query('SELECT * FROM workflows WHERE id = \$1', [id]);
    return result.rows[0];
  }
}

module.exports = new WorkflowModel();
EOF

# Create workflow routes
cat << EOF > "$project_dir/server/src/routes/workflowRoutes.js"
// src/routes/workflowRoutes.js
const express = require('express');
const WorkflowModel = require('../models/Workflow');
const WorkflowService = require('../services/workflowService');

const router = express.Router();

router.post('/', async (req, res) => {
  try {
    const workflow = await WorkflowModel.createWorkflow(req.body);
    res.status(201).json(workflow);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

router.get('/', async (req, res) => {
  try {
    const workflows = await WorkflowModel.getWorkflows();
    res.json(workflows);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

router.post('/:id/execute', async (req, res) => {
  try {
    const workflow = await WorkflowModel.getWorkflowById(req.params.id);
    if (!workflow) {
      return res.status(404).json({ message: 'Workflow not found' });
    }
    const result = await WorkflowService.executeWorkflow(workflow, req.body);
    res.json(result);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

module.exports = router;
EOF

log "Workflows setup completed for $project_dir"


// /d/Node/utils/js-utils
// generate-ai-tools.js
const generateAITools = () => {
    const aiTools = [
      {
        name: 'SmartContractGenerator',
        description: 'AI-powered contract generation based on project details'
      },
      {
        name: 'AutomaticTimeTracker',
        description: 'AI-driven time tracking using computer vision and activity monitoring'
      },
      {
        name: 'IntelligentInvoicing',
        description: 'Automated invoice creation with smart line item suggestions'
      },
      {
        name: 'PredictiveAnalytics',
        description: 'AI-powered forecasting for project timelines and budgets'
      },
      {
        name: 'ClientInsightEngine',
        description: 'AI analysis of client interactions for relationship management'
      },
      {
        name: 'NLPFormProcessor',
        description: 'Natural Language Processing for form creation and analysis'
      },
      {
        name: 'AutomatedBookkeeper',
        description: 'AI-driven categorization and reconciliation of financial transactions'
      },
      {
        name: 'TaskPrioritizer',
        description: 'AI-powered task prioritization and scheduling optimization'
      },
      {
        name: 'ProjectOptimizer',
        description: 'Machine learning-based project timeline and resource allocation'
      },
      {
        name: 'SentimentAnalyzer',
        description: 'AI-driven analysis of client communication for sentiment insights'
      }
    ];

    aiTools.forEach(tool => {
      generateAIToolFile(tool.name, tool.description);
    });
  };

  const generateAIToolFile = (name, description) => {
    // Generate AI tool integration file
    // Include necessary API calls and data processing logic
    // Save to appropriate directory
  };

  generateAITools();
// generate-charts.js
const generateCharts = () => {
    const charts = [
      {
        name: 'RevenueOverTime',
        type: 'LineChart',
        data: 'invoices'
      },
      {
        name: 'ProjectStatus',
        type: 'PieChart',
        data: 'projects'
      },
      {
        name: 'TimeAllocation',
        type: 'BarChart',
        data: 'timeEntries'
      },
      {
        name: 'ExpenseCategories',
        type: 'DoughnutChart',
        data: 'expenses'
      },
      {
        name: 'ClientAcquisition',
        type: 'FunnelChart',
        data: 'clients'
      },
      {
        name: 'TaskCompletion',
        type: 'GanttChart',
        data: 'tasks'
      }
    ];

    charts.forEach(chart => {
      generateChartComponent(chart.name, chart.type, chart.data);
    });
  };

  const generateChartComponent = (name, type, data) => {
    // Generate React component for the chart
    // Include data fetching and processing logic
    // Integrate with a charting library (e.g., Chart.js, D3.js)
    // Save to appropriate directory
  };

  generateCharts();
// generate-components.js
const generateComponents = () => {
    const components = [
      'Dashboard',
      'ProjectList',
      'ProjectDetails',
      'TaskBoard',
      'TimeTracker',
      'InvoiceGenerator',
      'ProposalBuilder',
      'ContractEditor',
      'ClientPortal',
      'FormBuilder',
      'ExpenseTracker',
      'ReportingDashboard',
      'AIInsights'
    ];

    components.forEach(component => {
      generateComponentFile(component);
    });
  };

  const generateComponentFile = (name) => {
    // Generate React component with basic structure
    // Include AI integration where applicable
    // Save to appropriate directory
  };

  generateComponents();
// generate-forms-templates.js
const generateFormsAndTemplates = () => {
    const items = [
      {
        type: 'form',
        name: 'ClientOnboarding'
      },
      {
        type: 'form',
        name: 'ProjectFeedback'
      },
      {
        type: 'template',
        name: 'InvoiceTemplate'
      },
      {
        type: 'template',
        name: 'ProposalTemplate'
      },
      {
        type: 'template',
        name: 'ContractTemplate'
      },
      {
        type: 'template',
        name: 'ProjectBrief'
      }
    ];

    items.forEach(item => {
      if (item.type === 'form') {
        generateFormBuilder(item.name);
      } else {
        generateTemplateBuilder(item.name);
      }
    });
  };

  const generateFormBuilder = (name) => {
    // Generate dynamic form builder component
    // Include drag-and-drop functionality
    // Save to appropriate directory
  };

  const generateTemplateBuilder = (name) => {
    // Generate template builder with customizable sections
    // Include placeholder system for dynamic content
    // Save to appropriate directory
  };

  generateFormsAndTemplates();
// generate-mock-data.js
const fs = require('fs');
const path = require('path');

function generateMockData(projectName, dataType, count) {
  const projectDir = path.join('/d/Node/projects', projectName, 'src/mockData');

  if (!fs.existsSync(projectDir)) {
    fs.mkdirSync(projectDir, { recursive: true });
  }

  let data;

  switch (dataType) {
    case 'users':
      data = generateUsers(count);
      break;
    case 'products':
      data = generateProducts(count);
      break;
    case 'orders':
      data = generateOrders(count);
      break;
    default:
      console.error('Invalid data type');
      return;
  }

  fs.writeFileSync(path.join(projectDir, `${dataType}.json`), JSON.stringify(data, null, 2));
  console.log(`Mock ${dataType} data generated successfully.`);
}

function generateUsers(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    name: `User ${i + 1}`,
    email: `user${i + 1}@example.com`,
    age: Math.floor(Math.random() * 50) + 18
  }));
}

function generateProducts(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    name: `Product ${i + 1}`,
    price: parseFloat((Math.random() * 100).toFixed(2)),
    category: ['Electronics', 'Clothing', 'Books', 'Food'][Math.floor(Math.random() * 4)]
  }));
}

function generateOrders(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    userId: Math.floor(Math.random() * 100) + 1,
    products: Array.from({ length: Math.floor(Math.random() * 5) + 1 }, () => ({
      productId: Math.floor(Math.random() * 100) + 1,
      quantity: Math.floor(Math.random() * 5) + 1
    })),
    totalAmount: parseFloat((Math.random() * 500).toFixed(2)),
    date: new Date(Date.now() - Math.floor(Math.random() * 10000000000)).toISOString()
  }));
}

// Usage
const [,, projectName, dataType, count] = process.argv;
generateMockData(projectName, dataType, parseInt(count) || 10);
// generate-models.js
const generateModels = () => {
    const models = [
      {
        name: 'User',
        fields: ['name', 'email', 'password', 'role']
      },
      {
        name: 'Client',
        fields: ['name', 'email', 'company', 'projects']
      },
      {
        name: 'Project',
        fields: ['name', 'description', 'client', 'tasks', 'timeline', 'budget']
      },
      {
        name: 'Task',
        fields: ['name', 'description', 'project', 'assignee', 'status', 'dueDate']
      },
      {
        name: 'TimeEntry',
        fields: ['user', 'project', 'task', 'duration', 'date']
      },
      {
        name: 'Invoice',
        fields: ['client', 'project', 'items', 'total', 'status', 'dueDate']
      },
      {
        name: 'Proposal',
        fields: ['client', 'project', 'content', 'status', 'expiryDate']
      },
      {
        name: 'Contract',
        fields: ['client', 'project', 'content', 'status', 'signatureDate']
      },
      {
        name: 'Form',
        fields: ['name', 'fields', 'responses']
      },
      {
        name: 'Expense',
        fields: ['user', 'project', 'amount', 'category', 'date']
      }
    ];

    models.forEach(model => {
      generateModelFile(model.name, model.fields);
    });
  };

  const generateModelFile = (name, fields) => {
    // Generate Mongoose schema and model
    // Save to appropriate directory
  };

  generateModels();
// utils/generate-project-readme.js
//Purpose: Generate comprehensive documentation for each directory.
const fs = require('fs');
const path = require('path');

// Define directories and files to exclude
const excludeExtensions = ['.pkl', '.png', '.jpg', '.jpeg', '.svg', '.ico', '.txt'];
const excludeDirectories = ['node_modules', 'docs', '.git', '.github', '.vscode', 'venv', 'docs'];
const excludeFiles = ['package-lock.json'];

// Logging function for debugging
function log(message) {
    console.log(`[DEBUG]: ${message}`);
}

// Function to generate README content for a directory
function generateReadmeForDirectory(directoryPath, directoryName) {
    let readmeContent = `# Directory: ${directoryName}\n\n`;

    const files = fs.readdirSync(directoryPath);
    files.forEach(file => {
        const filePath = path.join(directoryPath, file);
        const stat = fs.statSync(filePath);

        // Exclude unnecessary directories and files
        if (stat.isDirectory()) {
            if (!excludeDirectories.includes(file)) {
                log(`Including directory: ${file}`);
                readmeContent += generateReadmeForDirectory(filePath, file);
            } else {
                log(`Excluding directory: ${file}`);
            }
        } else if (stat.isFile()) {
            if (file === 'package.json' || (!excludeFiles.includes(file) && !excludeExtensions.includes(path.extname(file)))) {
                log(`Including file: ${file}`);
                readmeContent += `## File: ${file}\n\n`;
                readmeContent += fs.readFileSync(filePath, 'utf-8') + '\n\n';
            } else {
                log(`Excluding file: ${file}`);
            }
        }
    });

    return readmeContent;
}

// Generate README for the project root
const projectRoot = path.join(__dirname, '.');
const readmeContent = generateReadmeForDirectory(projectRoot, 'Project Root');

// Write the generated README to a file
fs.writeFileSync(path.join(projectRoot, './README.txt'), readmeContent);
console.log('README.txt generated successfully.');
// generate-routes.js
const generateRoutes = () => {
    const routes = [
      { path: '/api/users', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/clients', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/projects', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/tasks', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/time-entries', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/invoices', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/proposals', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/contracts', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/forms', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/expenses', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/reports', methods: ['GET'] },
      { path: '/api/ai-insights', methods: ['GET'] }
    ];

    routes.forEach(route => {
      generateRouteFile(route.path, route.methods);
    });
  };

  const generateRouteFile = (path, methods) => {
    // Generate Express.js route file with CRUD operations
    // Include input validation and error handling
    // Save to appropriate directory
  };

  generateRoutes();
