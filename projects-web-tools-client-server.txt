// server/src/utils/js-utils/*.js
// generate-ai-tools.js
const generateAITools = () => {
    const aiTools = [
      {
        name: 'SmartContractGenerator',
        description: 'AI-powered contract generation based on project details'
      },
      {
        name: 'AutomaticTimeTracker',
        description: 'AI-driven time tracking using computer vision and activity monitoring'
      },
      {
        name: 'IntelligentInvoicing',
        description: 'Automated invoice creation with smart line item suggestions'
      },
      {
        name: 'PredictiveAnalytics',
        description: 'AI-powered forecasting for project timelines and budgets'
      },
      {
        name: 'ClientInsightEngine',
        description: 'AI analysis of client interactions for relationship management'
      },
      {
        name: 'NLPFormProcessor',
        description: 'Natural Language Processing for form creation and analysis'
      },
      {
        name: 'AutomatedBookkeeper',
        description: 'AI-driven categorization and reconciliation of financial transactions'
      },
      {
        name: 'TaskPrioritizer',
        description: 'AI-powered task prioritization and scheduling optimization'
      },
      {
        name: 'ProjectOptimizer',
        description: 'Machine learning-based project timeline and resource allocation'
      },
      {
        name: 'SentimentAnalyzer',
        description: 'AI-driven analysis of client communication for sentiment insights'
      }
    ];

    aiTools.forEach(tool => {
      generateAIToolFile(tool.name, tool.description);
    });
  };

  const generateAIToolFile = (name, description) => {
    // Generate AI tool integration file
    // Include necessary API calls and data processing logic
    // Save to appropriate directory
  };

  generateAITools();
// generate-charts.js
const generateCharts = () => {
    const charts = [
      {
        name: 'RevenueOverTime',
        type: 'LineChart',
        data: 'invoices'
      },
      {
        name: 'ProjectStatus',
        type: 'PieChart',
        data: 'projects'
      },
      {
        name: 'TimeAllocation',
        type: 'BarChart',
        data: 'timeEntries'
      },
      {
        name: 'ExpenseCategories',
        type: 'DoughnutChart',
        data: 'expenses'
      },
      {
        name: 'ClientAcquisition',
        type: 'FunnelChart',
        data: 'clients'
      },
      {
        name: 'TaskCompletion',
        type: 'GanttChart',
        data: 'tasks'
      }
    ];

    charts.forEach(chart => {
      generateChartComponent(chart.name, chart.type, chart.data);
    });
  };

  const generateChartComponent = (name, type, data) => {
    // Generate React component for the chart
    // Include data fetching and processing logic
    // Integrate with a charting library (e.g., Chart.js, D3.js)
    // Save to appropriate directory
  };

  generateCharts();
// generate-components.js
const generateComponents = () => {
    const components = [
      'Dashboard',
      'ProjectList',
      'ProjectDetails',
      'TaskBoard',
      'TimeTracker',
      'InvoiceGenerator',
      'ProposalBuilder',
      'ContractEditor',
      'ClientPortal',
      'FormBuilder',
      'ExpenseTracker',
      'ReportingDashboard',
      'AIInsights'
    ];

    components.forEach(component => {
      generateComponentFile(component);
    });
  };

  const generateComponentFile = (name) => {
    // Generate React component with basic structure
    // Include AI integration where applicable
    // Save to appropriate directory
  };

  generateComponents();
// generate-forms-templates.js
const generateFormsAndTemplates = () => {
    const items = [
      {
        type: 'form',
        name: 'ClientOnboarding'
      },
      {
        type: 'form',
        name: 'ProjectFeedback'
      },
      {
        type: 'template',
        name: 'InvoiceTemplate'
      },
      {
        type: 'template',
        name: 'ProposalTemplate'
      },
      {
        type: 'template',
        name: 'ContractTemplate'
      },
      {
        type: 'template',
        name: 'ProjectBrief'
      }
    ];

    items.forEach(item => {
      if (item.type === 'form') {
        generateFormBuilder(item.name);
      } else {
        generateTemplateBuilder(item.name);
      }
    });
  };

  const generateFormBuilder = (name) => {
    // Generate dynamic form builder component
    // Include drag-and-drop functionality
    // Save to appropriate directory
  };

  const generateTemplateBuilder = (name) => {
    // Generate template builder with customizable sections
    // Include placeholder system for dynamic content
    // Save to appropriate directory
  };

  generateFormsAndTemplates();
// generate-mock-data.js
const fs = require('fs');
const path = require('path');

function generateMockData(projectName, dataType, count) {
  const projectDir = path.join('/d/Node/projects', projectName, 'src/mockData');

  if (!fs.existsSync(projectDir)) {
    fs.mkdirSync(projectDir, { recursive: true });
  }

  let data;

  switch (dataType) {
    case 'users':
      data = generateUsers(count);
      break;
    case 'products':
      data = generateProducts(count);
      break;
    case 'orders':
      data = generateOrders(count);
      break;
    default:
      console.error('Invalid data type');
      return;
  }

  fs.writeFileSync(path.join(projectDir, `${dataType}.json`), JSON.stringify(data, null, 2));
  console.log(`Mock ${dataType} data generated successfully.`);
}

function generateUsers(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    name: `User ${i + 1}`,
    email: `user${i + 1}@example.com`,
    age: Math.floor(Math.random() * 50) + 18
  }));
}

function generateProducts(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    name: `Product ${i + 1}`,
    price: parseFloat((Math.random() * 100).toFixed(2)),
    category: ['Electronics', 'Clothing', 'Books', 'Food'][Math.floor(Math.random() * 4)]
  }));
}

function generateOrders(count) {
  return Array.from({ length: count }, (_, i) => ({
    id: i + 1,
    userId: Math.floor(Math.random() * 100) + 1,
    products: Array.from({ length: Math.floor(Math.random() * 5) + 1 }, () => ({
      productId: Math.floor(Math.random() * 100) + 1,
      quantity: Math.floor(Math.random() * 5) + 1
    })),
    totalAmount: parseFloat((Math.random() * 500).toFixed(2)),
    date: new Date(Date.now() - Math.floor(Math.random() * 10000000000)).toISOString()
  }));
}

// Usage
const [,, projectName, dataType, count] = process.argv;
generateMockData(projectName, dataType, parseInt(count) || 10);
// generate-models.js
const generateModels = () => {
    const models = [
      {
        name: 'User',
        fields: ['name', 'email', 'password', 'role']
      },
      {
        name: 'Client',
        fields: ['name', 'email', 'company', 'projects']
      },
      {
        name: 'Project',
        fields: ['name', 'description', 'client', 'tasks', 'timeline', 'budget']
      },
      {
        name: 'Task',
        fields: ['name', 'description', 'project', 'assignee', 'status', 'dueDate']
      },
      {
        name: 'TimeEntry',
        fields: ['user', 'project', 'task', 'duration', 'date']
      },
      {
        name: 'Invoice',
        fields: ['client', 'project', 'items', 'total', 'status', 'dueDate']
      },
      {
        name: 'Proposal',
        fields: ['client', 'project', 'content', 'status', 'expiryDate']
      },
      {
        name: 'Contract',
        fields: ['client', 'project', 'content', 'status', 'signatureDate']
      },
      {
        name: 'Form',
        fields: ['name', 'fields', 'responses']
      },
      {
        name: 'Expense',
        fields: ['user', 'project', 'amount', 'category', 'date']
      }
    ];

    models.forEach(model => {
      generateModelFile(model.name, model.fields);
    });
  };

  const generateModelFile = (name, fields) => {
    // Generate Mongoose schema and model
    // Save to appropriate directory
  };

  generateModels();
// utils/generate-project-readme.js
//Purpose: Generate comprehensive documentation for each directory.
const fs = require('fs');
const path = require('path');

// Define directories and files to exclude
const excludeExtensions = ['.pkl', '.png', '.jpg', '.jpeg', '.svg', '.ico', '.txt'];
const excludeDirectories = ['node_modules', 'docs', '.git', '.github', '.vscode', 'venv', 'docs'];
const excludeFiles = ['package-lock.json'];

// Logging function for debugging
function log(message) {
    console.log(`[DEBUG]: ${message}`);
}

// Function to generate README content for a directory
function generateReadmeForDirectory(directoryPath, directoryName) {
    let readmeContent = `# Directory: ${directoryName}\n\n`;

    const files = fs.readdirSync(directoryPath);
    files.forEach(file => {
        const filePath = path.join(directoryPath, file);
        const stat = fs.statSync(filePath);

        // Exclude unnecessary directories and files
        if (stat.isDirectory()) {
            if (!excludeDirectories.includes(file)) {
                log(`Including directory: ${file}`);
                readmeContent += generateReadmeForDirectory(filePath, file);
            } else {
                log(`Excluding directory: ${file}`);
            }
        } else if (stat.isFile()) {
            if (file === 'package.json' || (!excludeFiles.includes(file) && !excludeExtensions.includes(path.extname(file)))) {
                log(`Including file: ${file}`);
                readmeContent += `## File: ${file}\n\n`;
                readmeContent += fs.readFileSync(filePath, 'utf-8') + '\n\n';
            } else {
                log(`Excluding file: ${file}`);
            }
        }
    });

    return readmeContent;
}

// Generate README for the project root
const projectRoot = path.join(__dirname, '.');
const readmeContent = generateReadmeForDirectory(projectRoot, 'Project Root');

// Write the generated README to a file
fs.writeFileSync(path.join(projectRoot, './README.txt'), readmeContent);
console.log('README.txt generated successfully.');
// generate-routes.js
const generateRoutes = () => {
    const routes = [
      { path: '/api/users', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/clients', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/projects', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/tasks', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/time-entries', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/invoices', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/proposals', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/contracts', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/forms', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/expenses', methods: ['GET', 'POST', 'PUT', 'DELETE'] },
      { path: '/api/reports', methods: ['GET'] },
      { path: '/api/ai-insights', methods: ['GET'] }
    ];

    routes.forEach(route => {
      generateRouteFile(route.path, route.methods);
    });
  };

  const generateRouteFile = (path, methods) => {
    // Generate Express.js route file with CRUD operations
    // Include input validation and error handling
    // Save to appropriate directory
  };

  generateRoutes();

// web-tools/client/src/components/*.js

import React from 'react';

const About = () => {
  return (
    <div>
      <h1>About</h1>
    </div>
  );
};

export default About;
// client/src/components/BusinessForm.js
import React, { useState } from 'react';
import axios from 'axios';

function BusinessForm() {
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [category, setCategory] = useState('');
    const [address, setAddress] = useState('');
    const [contactInfo, setContactInfo] = useState('');
    const [hours, setHours] = useState('');
    const [isFeatured, setIsFeatured] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/businesses/add', { name, description, category, address, contactInfo, hours, isFeatured });
            alert('Business added successfully');
        } catch (error) {
            alert('Error adding business');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Business</h1>
            <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Business Name" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="text" value={category} onChange={(e) => setCategory(e.target.value)} placeholder="Category" required />
            <input type="text" value={address} onChange={(e) => setAddress(e.target.value)} placeholder="Address" required />
            <input type="text" value={contactInfo} onChange={(e) => setContactInfo(e.target.value)} placeholder="Contact Info" required />
            <input type="text" value={hours} onChange={(e) => setHours(e.target.value)} placeholder="Hours of Operation" required />
            <label>
                <input type="checkbox" checked={isFeatured} onChange={(e) => setIsFeatured(e.target.checked)} />
                Featured Listing
            </label>
            <button type="submit">Add Business</button>
        </form>
    );
}

export default BusinessForm;
// client/src/components/BusinessList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function BusinessList() {
    const [businesses, setBusinesses] = useState([]);

    useEffect(() => {
        axios.get('/api/businesses/all')
            .then(response => setBusinesses(response.data))
            .catch(error => console.error('Error fetching businesses:', error));
    }, []);

    return (
        <div>
            <h1>Business Directory</h1>
            <ul>
                {businesses.map(business => (
                    <li key={business._id}>
                        <h2>{business.name}</h2>
                        <p>{business.description}</p>
                        <p>Category: {business.category}</p>
                        <p>Address: {business.address}</p>
                        <p>Contact Info: {business.contactInfo}</p>
                        <p>Hours: {business.hours}</p>
                        <p>Owner: {business.owner.username}</p>
                        {business.isFeatured && <p>Featured Listing</p>}
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default BusinessList;
import React from 'react';

const Contact = () => {
  return (
    <div>
      <h1>Contact</h1>
    </div>
  );
};

export default Contact;
// client/src/components/CreatePoll.js
import React, { useState } from 'react';

const CreatePoll = () => {
  const [question, setQuestion] = useState('');
  const [options, setOptions] = useState(['', '']);

  const handleOptionChange = (index, value) => {
    const newOptions = [...options];
    newOptions[index] = value;
    setOptions(newOptions);
  };

  const addOption = () => {
    setOptions([...options, '']);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Implement API call to create poll
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Question</label>
        <input type="text" value={question} onChange={(e) => setQuestion(e.target.value)} required />
      </div>
      <div>
        <label>Options</label>
        {options.map((option, index) => (
          <input key={index} type="text" value={option} onChange={(e) => handleOptionChange(index, e.target.value)} required />
        ))}
        <button type="button" onClick={addOption}>Add Option</button>
      </div>
      <button type="submit">Create Poll</button>
    </form>
  );
};

export default CreatePoll;
// client/src/components/Dashboard.js
import React from 'react';

function Dashboard() {
    return (
        <div>
            <h1>Dashboard</h1>
            <p>Welcome to your dashboard</p>
        </div>
    );
}

export default Dashboard;
// client/src/components/EventForm.js
import React, { useState } from 'react';
import axios from 'axios';

function EventForm() {
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [date, setDate] = useState('');
    const [time, setTime] = useState('');
    const [location, setLocation] = useState('');
    const [isRecurring, setIsRecurring] = useState(false);
    const [category, setCategory] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/events/add', { title, description, date, time, location, isRecurring, category });
            alert('Event added successfully');
        } catch (error) {
            alert('Error adding event');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Event</h1>
            <input type="text" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Event Title" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="date" value={date} onChange={(e) => setDate(e.target.value)} required />
            <input type="time" value={time} onChange={(e) => setTime(e.target.value)} required />
            <input type="text" value={location} onChange={(e) => setLocation(e.target.value)} placeholder="Location" required />
            <label>
                <input type="checkbox" checked={isRecurring} onChange={(e) => setIsRecurring(e.target.checked)} />
                Recurring Event
            </label>
            <input type="text" value={category} onChange={(e) => setCategory(e.target.value)} placeholder="Category" required />
            <button type="submit">Add Event</button>
        </form>
    );
}

export default EventForm;
// client/src/components/EventList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function EventList() {
    const [events, setEvents] = useState([]);

    useEffect(() => {
        axios.get('/api/events/all')
            .then(response => setEvents(response.data))
            .catch(error => console.error('Error fetching events:', error));
    }, []);

    return (
        <div>
            <h1>Upcoming Events</h1>
            <ul>
                {events.map(event => (
                    <li key={event._id}>
                        <h2>{event.title}</h2>
                        <p>{event.description}</p>
                        <p>Date: {new Date(event.date).toLocaleDateString()}</p>
                        <p>Time: {event.time}</p>
                        <p>Location: {event.location}</p>
                        <p>Category: {event.category}</p>
                        <p>Organizer: {event.organizer.username}</p>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default EventList;
// client/src/components/Features.js
import React from 'react';
import './Features.css';

const Features = () => {
  return (
    <section id="features" className="features">
      <div className="container">
        <h2 className="section-title">Features</h2>
        <div className="features-grid">
          <div className="feature-item">
            <h3>Feature 1</h3>
            <p>Description of feature 1.</p>
          </div>
          <div className="feature-item">
            <h3>Feature 2</h3>
            <p>Description of feature 2.</p>
          </div>
          <div className="feature-item">
            <h3>Feature 3</h3>
            <p>Description of feature 3.</p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default Features;
// client/src/components/Footer.js
import React from 'react';
import './Footer.css';

const Footer = () => {
  return (
    <footer className="footer">
      <div className="container">
        <p>&copy; 2024 County Web Tools. All rights reserved.</p>
        <div className="footer-links">
          <a href="#privacy">Privacy Policy</a>
          <a href="#terms">Terms of Service</a>
        </div>
      </div>
    </footer>
  );
};

export default Footer;
// client/src/components/Hero.js
import React from 'react';
import './Hero.css';

const Hero = () => {
  return (
    <section className="hero">
      <div className="hero-content">
        <h1 className="hero-title">Welcome to Our Service</h1>
        <p className="hero-subtitle">We help you manage your projects efficiently.</p>
        <div className="hero-buttons">
          <a href="#signup" className="hero-button">Get Started</a>
          <a href="#learn-more" className="hero-button secondary">Learn More</a>
        </div>
      </div>
    </section>
  );
};

export default Hero;
import React, { useEffect, useState } from 'react';

const Home = () => {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetch('/api/services')
      .then(response => response.json())
      .then(data => setData(data))
      .catch(error => console.error('Error fetching data:', error));
  }, []);

  return (
    <div>
      <h1>Home</h1>
      <ul>
        {data.map(service => (
          <li key={service.id}>{service.name}</li>
        ))}
      </ul>
    </div>
  );
};

export default Home;
// client/src/components/Login.js
import React, { useState } from 'react';
import axios from 'axios';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleLogin = async () => {
        try {
            await axios.post('http://localhost:3000/login', { username, password });
            alert('User logged in successfully');
        } catch (error) {
            alert(error.message);
        }
    };

    return (
        <div>
            <h1>Login</h1>
            <input
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="Username"
            />
            <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Password"
            />
            <button onClick={handleLogin}>Login</button>
        </div>
    );
}

export default Login;
// client/src/components/Navbar.js
import React from 'react';
import './Navbar.css';

const Navbar = () => {
  return (
    <nav className="navbar">
      <div className="navbar-container">
        <a href="/" className="navbar-logo">Logo</a>
        <ul className="navbar-menu">
          <li className="navbar-item"><a href="#features" className="navbar-link">Features</a></li>
          <li className="navbar-item"><a href="#testimonials" className="navbar-link">Testimonials</a></li>
          <li className="navbar-item"><a href="#contact" className="navbar-link">Contact</a></li>
          <li className="navbar-item"><a href="#signup" className="navbar-link navbar-link-cta">Sign Up</a></li>
        </ul>
      </div>
    </nav>
  );
};

export default Navbar;import React from 'react';

const NotFound = () => {
  return (
    <div>
      <h1>404 Not Found</h1>
    </div>
  );
};

export default NotFound;
// client/src/components/Polls.js
import React, { useEffect, useState } from 'react';

const Polls = () => {
  const [polls, setPolls] = useState([]);

  useEffect(() => {
    // Fetch polls from the backend
  }, []);

  return (
    <div>
      <h1>Polls</h1>
      {polls.map(poll => (
        <div key={poll.id}>
          <h2>{poll.question}</h2>
          <ul>
            {poll.options.map(option => (
              <li key={option.option}>
                {option.option}: {option.votes} votes
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
};

export default Polls;
// client/src/components/Register.js
import React, { useState } from 'react';
import axios from 'axios';

function Register() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await axios.post('/api/register', { username, password });
      alert('User registered successfully!');
    } catch (error) {
      alert('Error registering user');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="username"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="Username"
      />
      <input
        type="password"
        name="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Register</button>
    </form>
  );
}

export default Register;
// client/src/components/ReviewForm.js
import React, { useState } from 'react';
import axios from 'axios';

function ReviewForm({ businessId }) {
    const [rating, setRating] = useState(1);
    const [comment, setComment] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/reviews/add', { businessId, rating, comment });
            alert('Review added successfully');
        } catch (error) {
            alert('Error adding review');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a Review</h1>
            <label>
                Rating:
                <select value={rating} onChange={(e) => setRating(e.target.value)}>
                    {[1, 2, 3, 4, 5].map(num => (
                        <option key={num} value={num}>{num}</option>
                    ))}
                </select>
            </label>
            <textarea value={comment} onChange={(e) => setComment(e.target.value)} placeholder="Comment" required />
            <button type="submit">Add Review</button>
        </form>
    );
}

export default ReviewForm;
// client/src/components/ReviewList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ReviewList({ businessId }) {
    const [reviews, setReviews] = useState([]);

    useEffect(() => {
        axios.get(`/api/reviews/business/${businessId}`)
            .then(response => setReviews(response.data))
            .catch(error => console.error('Error fetching reviews:', error));
    }, [businessId]);

    return (
        <div>
            <h1>Reviews</h1>
            <ul>
                {reviews.map(review => (
                    <li key={review._id}>
                        <h2>{review.user.username}</h2>
                        <p>Rating: {review.rating}</p>
                        <p>{review.comment}</p>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default ReviewList;
// client/src/components/ServiceForm.js
import React, { useState } from 'react';
import axios from 'axios';

function ServiceForm() {
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [price, setPrice] = useState('');
    const [duration, setDuration] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/services/add', { name, description, price, duration });
            alert('Service added successfully');
        } catch (error) {
            alert('Error adding service');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Service</h1>
            <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Service Name" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="number" value={price} onChange={(e) => setPrice(e.target.value)} placeholder="Price" required />
            <input type="number" value={duration} onChange={(e) => setDuration(e.target.value)} placeholder="Duration (minutes)" required />
            <button type="submit">Add Service</button>
        </form>
    );
}

export default ServiceForm;
// client/src/components/ServiceList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ServiceList() {
    const [services, setServices] = useState([]);

    useEffect(() => {
        axios.get('/api/services')
            .then(response => setServices(response.data))
            .catch(error => console.error('Error fetching services:', error));
    }, []);

    return (
        <div>
            <h1>Available Services</h1>
            <ul>
                {services.map(service => (
                    <li key={service._id}>
                        <h2>{service.name}</h2>
                        <p>{service.description}</p>
                        <p>Price: ${service.price}</p>
                        <p>Duration: {service.duration} minutes</p>
                        <button>Book Now</button>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default ServiceList;
import React from 'react';

const Services = () => {
  return (
    <div>
      <h1>Services</h1>
    </div>
  );
};

export default Services;
// client/src/components/Testimonials.js
import React from 'react';
import './Testimonials.css';

const Testimonials = () => {
  return (
    <section id="testimonials" className="testimonials">
      <div className="container">
        <h2 className="section-title">Testimonials</h2>
        <div className="testimonials-grid">
          <div className="testimonial-item">
            <p>"This service is amazing!" - User 1</p>
          </div>
          <div className="testimonial-item">
            <p>"Highly recommend to everyone." - User 2</p>
          </div>
          <div className="testimonial-item">
            <p>"Changed my life for the better." - User 3</p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default Testimonials;
// client/src/components/ThemeToggle.js
import React, { useState, useEffect } from 'react';

const ThemeToggle = () => {
  const [theme, setTheme] = useState('light');

  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  return <button onClick={toggleTheme}>Toggle Theme</button>;
};

export default ThemeToggle;

// client/src/components/*.css
import React from 'react';

const About = () => {
  return (
    <div>
      <h1>About</h1>
    </div>
  );
};

export default About;
// client/src/components/BusinessForm.js
import React, { useState } from 'react';
import axios from 'axios';

function BusinessForm() {
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [category, setCategory] = useState('');
    const [address, setAddress] = useState('');
    const [contactInfo, setContactInfo] = useState('');
    const [hours, setHours] = useState('');
    const [isFeatured, setIsFeatured] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/businesses/add', { name, description, category, address, contactInfo, hours, isFeatured });
            alert('Business added successfully');
        } catch (error) {
            alert('Error adding business');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Business</h1>
            <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Business Name" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="text" value={category} onChange={(e) => setCategory(e.target.value)} placeholder="Category" required />
            <input type="text" value={address} onChange={(e) => setAddress(e.target.value)} placeholder="Address" required />
            <input type="text" value={contactInfo} onChange={(e) => setContactInfo(e.target.value)} placeholder="Contact Info" required />
            <input type="text" value={hours} onChange={(e) => setHours(e.target.value)} placeholder="Hours of Operation" required />
            <label>
                <input type="checkbox" checked={isFeatured} onChange={(e) => setIsFeatured(e.target.checked)} />
                Featured Listing
            </label>
            <button type="submit">Add Business</button>
        </form>
    );
}

export default BusinessForm;
// client/src/components/BusinessList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function BusinessList() {
    const [businesses, setBusinesses] = useState([]);

    useEffect(() => {
        axios.get('/api/businesses/all')
            .then(response => setBusinesses(response.data))
            .catch(error => console.error('Error fetching businesses:', error));
    }, []);

    return (
        <div>
            <h1>Business Directory</h1>
            <ul>
                {businesses.map(business => (
                    <li key={business._id}>
                        <h2>{business.name}</h2>
                        <p>{business.description}</p>
                        <p>Category: {business.category}</p>
                        <p>Address: {business.address}</p>
                        <p>Contact Info: {business.contactInfo}</p>
                        <p>Hours: {business.hours}</p>
                        <p>Owner: {business.owner.username}</p>
                        {business.isFeatured && <p>Featured Listing</p>}
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default BusinessList;
import React from 'react';

const Contact = () => {
  return (
    <div>
      <h1>Contact</h1>
    </div>
  );
};

export default Contact;
// client/src/components/CreatePoll.js
import React, { useState } from 'react';

const CreatePoll = () => {
  const [question, setQuestion] = useState('');
  const [options, setOptions] = useState(['', '']);

  const handleOptionChange = (index, value) => {
    const newOptions = [...options];
    newOptions[index] = value;
    setOptions(newOptions);
  };

  const addOption = () => {
    setOptions([...options, '']);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Implement API call to create poll
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Question</label>
        <input type="text" value={question} onChange={(e) => setQuestion(e.target.value)} required />
      </div>
      <div>
        <label>Options</label>
        {options.map((option, index) => (
          <input key={index} type="text" value={option} onChange={(e) => handleOptionChange(index, e.target.value)} required />
        ))}
        <button type="button" onClick={addOption}>Add Option</button>
      </div>
      <button type="submit">Create Poll</button>
    </form>
  );
};

export default CreatePoll;
// client/src/components/Dashboard.js
import React from 'react';

function Dashboard() {
    return (
        <div>
            <h1>Dashboard</h1>
            <p>Welcome to your dashboard</p>
        </div>
    );
}

export default Dashboard;
// client/src/components/EventForm.js
import React, { useState } from 'react';
import axios from 'axios';

function EventForm() {
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [date, setDate] = useState('');
    const [time, setTime] = useState('');
    const [location, setLocation] = useState('');
    const [isRecurring, setIsRecurring] = useState(false);
    const [category, setCategory] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/events/add', { title, description, date, time, location, isRecurring, category });
            alert('Event added successfully');
        } catch (error) {
            alert('Error adding event');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Event</h1>
            <input type="text" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Event Title" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="date" value={date} onChange={(e) => setDate(e.target.value)} required />
            <input type="time" value={time} onChange={(e) => setTime(e.target.value)} required />
            <input type="text" value={location} onChange={(e) => setLocation(e.target.value)} placeholder="Location" required />
            <label>
                <input type="checkbox" checked={isRecurring} onChange={(e) => setIsRecurring(e.target.checked)} />
                Recurring Event
            </label>
            <input type="text" value={category} onChange={(e) => setCategory(e.target.value)} placeholder="Category" required />
            <button type="submit">Add Event</button>
        </form>
    );
}

export default EventForm;
// client/src/components/EventList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function EventList() {
    const [events, setEvents] = useState([]);

    useEffect(() => {
        axios.get('/api/events/all')
            .then(response => setEvents(response.data))
            .catch(error => console.error('Error fetching events:', error));
    }, []);

    return (
        <div>
            <h1>Upcoming Events</h1>
            <ul>
                {events.map(event => (
                    <li key={event._id}>
                        <h2>{event.title}</h2>
                        <p>{event.description}</p>
                        <p>Date: {new Date(event.date).toLocaleDateString()}</p>
                        <p>Time: {event.time}</p>
                        <p>Location: {event.location}</p>
                        <p>Category: {event.category}</p>
                        <p>Organizer: {event.organizer.username}</p>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default EventList;
// client/src/components/Features.js
import React from 'react';
import './Features.css';

const Features = () => {
  return (
    <section id="features" className="features">
      <div className="container">
        <h2 className="section-title">Features</h2>
        <div className="features-grid">
          <div className="feature-item">
            <h3>Feature 1</h3>
            <p>Description of feature 1.</p>
          </div>
          <div className="feature-item">
            <h3>Feature 2</h3>
            <p>Description of feature 2.</p>
          </div>
          <div className="feature-item">
            <h3>Feature 3</h3>
            <p>Description of feature 3.</p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default Features;
// client/src/components/Footer.js
import React from 'react';
import './Footer.css';

const Footer = () => {
  return (
    <footer className="footer">
      <div className="container">
        <p>&copy; 2024 County Web Tools. All rights reserved.</p>
        <div className="footer-links">
          <a href="#privacy">Privacy Policy</a>
          <a href="#terms">Terms of Service</a>
        </div>
      </div>
    </footer>
  );
};

export default Footer;
// client/src/components/Hero.js
import React from 'react';
import './Hero.css';

const Hero = () => {
  return (
    <section className="hero">
      <div className="hero-content">
        <h1 className="hero-title">Welcome to Our Service</h1>
        <p className="hero-subtitle">We help you manage your projects efficiently.</p>
        <div className="hero-buttons">
          <a href="#signup" className="hero-button">Get Started</a>
          <a href="#learn-more" className="hero-button secondary">Learn More</a>
        </div>
      </div>
    </section>
  );
};

export default Hero;
import React, { useEffect, useState } from 'react';

const Home = () => {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetch('/api/services')
      .then(response => response.json())
      .then(data => setData(data))
      .catch(error => console.error('Error fetching data:', error));
  }, []);

  return (
    <div>
      <h1>Home</h1>
      <ul>
        {data.map(service => (
          <li key={service.id}>{service.name}</li>
        ))}
      </ul>
    </div>
  );
};

export default Home;
// client/src/components/Login.js
import React, { useState } from 'react';
import axios from 'axios';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleLogin = async () => {
        try {
            await axios.post('http://localhost:3000/login', { username, password });
            alert('User logged in successfully');
        } catch (error) {
            alert(error.message);
        }
    };

    return (
        <div>
            <h1>Login</h1>
            <input
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="Username"
            />
            <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Password"
            />
            <button onClick={handleLogin}>Login</button>
        </div>
    );
}

export default Login;
// client/src/components/Navbar.js
import React from 'react';
import './Navbar.css';

const Navbar = () => {
  return (
    <nav className="navbar">
      <div className="navbar-container">
        <a href="/" className="navbar-logo">Logo</a>
        <ul className="navbar-menu">
          <li className="navbar-item"><a href="#features" className="navbar-link">Features</a></li>
          <li className="navbar-item"><a href="#testimonials" className="navbar-link">Testimonials</a></li>
          <li className="navbar-item"><a href="#contact" className="navbar-link">Contact</a></li>
          <li className="navbar-item"><a href="#signup" className="navbar-link navbar-link-cta">Sign Up</a></li>
        </ul>
      </div>
    </nav>
  );
};

export default Navbar;import React from 'react';

const NotFound = () => {
  return (
    <div>
      <h1>404 Not Found</h1>
    </div>
  );
};

export default NotFound;
// client/src/components/Polls.js
import React, { useEffect, useState } from 'react';

const Polls = () => {
  const [polls, setPolls] = useState([]);

  useEffect(() => {
    // Fetch polls from the backend
  }, []);

  return (
    <div>
      <h1>Polls</h1>
      {polls.map(poll => (
        <div key={poll.id}>
          <h2>{poll.question}</h2>
          <ul>
            {poll.options.map(option => (
              <li key={option.option}>
                {option.option}: {option.votes} votes
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
};

export default Polls;
// client/src/components/Register.js
import React, { useState } from 'react';
import axios from 'axios';

function Register() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await axios.post('/api/register', { username, password });
      alert('User registered successfully!');
    } catch (error) {
      alert('Error registering user');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="username"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="Username"
      />
      <input
        type="password"
        name="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Register</button>
    </form>
  );
}

export default Register;
// client/src/components/ReviewForm.js
import React, { useState } from 'react';
import axios from 'axios';

function ReviewForm({ businessId }) {
    const [rating, setRating] = useState(1);
    const [comment, setComment] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/reviews/add', { businessId, rating, comment });
            alert('Review added successfully');
        } catch (error) {
            alert('Error adding review');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a Review</h1>
            <label>
                Rating:
                <select value={rating} onChange={(e) => setRating(e.target.value)}>
                    {[1, 2, 3, 4, 5].map(num => (
                        <option key={num} value={num}>{num}</option>
                    ))}
                </select>
            </label>
            <textarea value={comment} onChange={(e) => setComment(e.target.value)} placeholder="Comment" required />
            <button type="submit">Add Review</button>
        </form>
    );
}

export default ReviewForm;
// client/src/components/ReviewList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ReviewList({ businessId }) {
    const [reviews, setReviews] = useState([]);

    useEffect(() => {
        axios.get(`/api/reviews/business/${businessId}`)
            .then(response => setReviews(response.data))
            .catch(error => console.error('Error fetching reviews:', error));
    }, [businessId]);

    return (
        <div>
            <h1>Reviews</h1>
            <ul>
                {reviews.map(review => (
                    <li key={review._id}>
                        <h2>{review.user.username}</h2>
                        <p>Rating: {review.rating}</p>
                        <p>{review.comment}</p>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default ReviewList;
// client/src/components/ServiceForm.js
import React, { useState } from 'react';
import axios from 'axios';

function ServiceForm() {
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [price, setPrice] = useState('');
    const [duration, setDuration] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/services/add', { name, description, price, duration });
            alert('Service added successfully');
        } catch (error) {
            alert('Error adding service');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Service</h1>
            <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Service Name" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="number" value={price} onChange={(e) => setPrice(e.target.value)} placeholder="Price" required />
            <input type="number" value={duration} onChange={(e) => setDuration(e.target.value)} placeholder="Duration (minutes)" required />
            <button type="submit">Add Service</button>
        </form>
    );
}

export default ServiceForm;
// client/src/components/ServiceList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ServiceList() {
    const [services, setServices] = useState([]);

    useEffect(() => {
        axios.get('/api/services')
            .then(response => setServices(response.data))
            .catch(error => console.error('Error fetching services:', error));
    }, []);

    return (
        <div>
            <h1>Available Services</h1>
            <ul>
                {services.map(service => (
                    <li key={service._id}>
                        <h2>{service.name}</h2>
                        <p>{service.description}</p>
                        <p>Price: ${service.price}</p>
                        <p>Duration: {service.duration} minutes</p>
                        <button>Book Now</button>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default ServiceList;
import React from 'react';

const Services = () => {
  return (
    <div>
      <h1>Services</h1>
    </div>
  );
};

export default Services;
// client/src/components/Testimonials.js
import React from 'react';
import './Testimonials.css';

const Testimonials = () => {
  return (
    <section id="testimonials" className="testimonials">
      <div className="container">
        <h2 className="section-title">Testimonials</h2>
        <div className="testimonials-grid">
          <div className="testimonial-item">
            <p>"This service is amazing!" - User 1</p>
          </div>
          <div className="testimonial-item">
            <p>"Highly recommend to everyone." - User 2</p>
          </div>
          <div className="testimonial-item">
            <p>"Changed my life for the better." - User 3</p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default Testimonials;
// client/src/components/ThemeToggle.js
import React, { useState, useEffect } from 'react';

const ThemeToggle = () => {
  const [theme, setTheme] = useState('light');

  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  return <button onClick={toggleTheme}>Toggle Theme</button>;
};

export default ThemeToggle;


// web-tools/server/src/config

// config/auth.js

module.exports = {
  ensureAuthenticated: function (req, res, next) {
    if (req.isAuthenticated()) {
      return next();
    }
    res.redirect('/login');
  },
  forwardAuthenticated: function (req, res, next) {
    if (!req.isAuthenticated()) {
      return next();
    }
    res.redirect('/dashboard');
  }
};
// config/commission.js
module.exports = {
    COMMISSION_PERCENTAGE: process.env.COMMISSION_PERCENTAGE || 10
};
// config/passport.js
const LocalStrategy = require('passport-local').Strategy;
const mongoose = require('mongoose');
const User = require('../models/User');

module.exports = function(passport) {
  passport.use(
    new LocalStrategy({ usernameField: 'email' }, (email, password, done) => {
      User.findOne({ email: email.toLowerCase() }, (err, user) => {
        if (err) return done(err);
        if (!user) {
          return done(null, false, { message: 'No user found with that email' });
        }
        user.matchPassword(password, (err, isMatch) => {
          if (err) return done(err);
          if (isMatch) {
            return done(null, user);
          } else {
            return done(null, false, { message: 'Password incorrect' });
          }
        });
      });
    })
  );

  passport.serializeUser((user, done) => {
    done(null, user.id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, (err, user) => {
      done(err, user);
    });
  });
};


// middleware/auth.js
module.exports = {
  ensureAuthenticated: (req, res, next) => {
    if (req.isAuthenticated()) {
      return next();
    }
    res.status(401).json({ error: 'Unauthorized' });
  }
};


// models/Business.js
const mongoose = require('mongoose');

const businessSchema = new mongoose.Schema({
    owner: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    name: { type: String, required: true },
    description: { type: String, required: true },
    category: { type: String, required: true },
    address: { type: String, required: true },
    contactInfo: { type: String, required: true },
    hours: { type: String, required: true },
    isFeatured: { type: Boolean, default: false },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Business', businessSchema);
// models/Event.js
const mongoose = require('mongoose');

const eventSchema = new mongoose.Schema({
    title: { type: String, required: true },
    description: { type: String, required: true },
    date: { type: Date, required: true },
    time: { type: String, required: true },
    location: { type: String, required: true },
    organizer: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    isRecurring: { type: Boolean, default: false },
    category: { type: String, required: true },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Event', eventSchema);
// models/Review.js
const mongoose = require('mongoose');

const reviewSchema = new mongoose.Schema({
    business: { type: mongoose.Schema.Types.ObjectId, ref: 'Business', required: true },
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    rating: { type: Number, required: true, min: 1, max: 5 },
    comment: { type: String, required: true },
    createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Review', reviewSchema);
// models/Service.js
const mongoose = require('mongoose');

const serviceSchema = new mongoose.Schema({
  name: { type: String, required: true },
  description: { type: String, required: true },
  provider: { type: String, required: true },
  duration: { type: Number, required: true },
  price: { type: Number, required: true }
});

const Service = mongoose.model('Service', serviceSchema);

module.exports = Service;
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const UserSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true
  },
  date: {
    type: Date,
    default: Date.now
  }
});

UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) {
    return next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

UserSchema.methods.matchPassword = async function(password) {
  return await bcrypt.compare(password, this.password);
};

module.exports = mongoose.model('User', UserSchema);


// routes/auth.js
const express = require('express');
const router = express.Router();
const passport = require('passport');
const User = require('../models/User');

// Register
router.post('/register', async (req, res) => {
  const { username, email, password } = req.body;
  try {
    const user = new User({ username, email, password });
    await user.save();
    res.status(201).json({ message: 'User registered successfully' });
  } catch (err) {
    res.status(400).json({ error: 'Error registering user' });
  }
});

// Login
router.post('/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    if (err) return next(err);
    if (!user) return res.status(400).json({ error: 'Invalid credentials' });
    req.logIn(user, (err) => {
      if (err) return next(err);
      res.status(200).json({ message: 'Logged in successfully' });
    });
  })(req, res, next);
});

// Logout
router.get('/logout', (req, res) => {
  req.logout((err) => {
    if (err) return res.status(500).json({ error: 'Error logging out' });
    res.status(200).json({ message: 'Logged out successfully' });
  });
});

module.exports = router;
// routes/businesses.js
const express = require('express');
const router = express.Router();
const Business = require('../models/Business');
const { ensureAuthenticated } = require('../config/auth');

// Add a new business listing
router.post('/add', ensureAuthenticated, async (req, res) => {
    const { name, description, category, address, contactInfo, hours, isFeatured } = req.body;
    try {
        const newBusiness = new Business({
            owner: req.user.id,
            name,
            description,
            category,
            address,
            contactInfo,
            hours,
            isFeatured
        });
        await newBusiness.save();
        res.status(201).send('Business added successfully');
    } catch (error) {
        res.status(500).send('Error adding business');
    }
});

// Update a business listing
router.put('/update/:id', ensureAuthenticated, async (req, res) => {
    const { name, description, category, address, contactInfo, hours, isFeatured } = req.body;
    try {
        await Business.findByIdAndUpdate(req.params.id, { name, description, category, address, contactInfo, hours, isFeatured });
        res.status(200).send('Business updated successfully');
    } catch (error) {
        res.status(500).send('Error updating business');
    }
});

// Delete a business listing
router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
    try {
        await Business.findByIdAndRemove(req.params.id);
        res.status(200).send('Business deleted successfully');
    } catch (error) {
        res.status(500).send('Error deleting business');
    }
});

// Get all business listings
router.get('/all', async (req, res) => {
    try {
        const businesses = await Business.find().populate('owner', 'username');
        res.status(200).json(businesses);
    } catch (error) {
        res.status(500).send('Error fetching businesses');
    }
});

module.exports = router;
// routes/events.js
const express = require('express');
const router = express.Router();
const Event = require('../models/Event');
const { ensureAuthenticated } = require('../config/auth');

// Add a new event
router.post('/add', ensureAuthenticated, async (req, res) => {
    const { title, description, date, time, location, isRecurring, category } = req.body;
    try {
        const newEvent = new Event({
            title,
            description,
            date,
            time,
            location,
            isRecurring,
            category,
            organizer: req.user.id
        });
        await newEvent.save();
        res.status(201).send('Event added successfully');
    } catch (error) {
        res.status(500).send('Error adding event');
    }
});

// Update an event
router.put('/update/:id', ensureAuthenticated, async (req, res) => {
    const { title, description, date, time, location, isRecurring, category } = req.body;
    try {
        await Event.findByIdAndUpdate(req.params.id, { title, description, date, time, location, isRecurring, category });
        res.status(200).send('Event updated successfully');
    } catch (error) {
        res.status(500).send('Error updating event');
    }
});

// Delete an event
router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
    try {
        await Event.findByIdAndRemove(req.params.id);
        res.status(200).send('Event deleted successfully');
    } catch (error) {
        res.status(500).send('Error deleting event');
    }
});

// Get all events
router.get('/all', async (req, res) => {
    try {
        const events = await Event.find().populate('organizer', 'username');
        res.status(200).json(events);
    } catch (error) {
        res.status(500).send('Error fetching events');
    }
});

module.exports = router;
// routes/payments.js
const express = require('express');
const router = express.Router();
const fetch = require('node-fetch'); // Use CommonJS syntax
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY, {
  httpClient: require('stripe').createFetchHttpClient(fetch), // Provide fetch implementation
});

const { COMMISSION_PERCENTAGE } = require('../config/commission');
const Service = require('../models/Service');

// Route for booking a service and processing the payment
router.post('/book', async (req, res) => {
  const { serviceId, paymentMethodId } = req.body;
  try {
    const service = await Service.findById(serviceId).populate('provider');
    const commission = (service.price * COMMISSION_PERCENTAGE) / 100;
    const totalAmount = service.price + commission;

    const paymentIntent = await stripe.paymentIntents.create({
      amount: totalAmount * 100, // in cents
      currency: 'usd',
      payment_method: paymentMethodId,
      confirm: true,
      transfer_data: {
        destination: service.provider.stripeAccountId, // Assuming the provider has a Stripe account
        amount: (service.price - commission) * 100 // amount in cents
      }
    });

    res.status(200).send('Payment successful');
  } catch (error) {
    res.status(500).send('Error processing payment');
  }
});

router.post('/create-payment-intent', async (req, res) => {
  const { amount, currency } = req.body;

  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency,
      payment_method_types: ['card']
    });

    res.status(200).send({
      clientSecret: paymentIntent.client_secret
    });
  } catch (err) {
    res.status(500).send({ error: err.message });
  }
});

module.exports = router;
// routes/polls.js
const express = require('express');
const router = express.Router();
const Poll = require('../models/Poll');
const { ensureAuthenticated } = require('../middleware/auth');

// Create Poll
router.post('/create', ensureAuthenticated, async (req, res) => {
  const { question, options } = req.body;
  try {
    const poll = new Poll({ question, options, createdBy: req.user.id });
    await poll.save();
    res.status(201).json({ message: 'Poll created successfully' });
  } catch (err) {
    res.status(400).json({ error: 'Error creating poll' });
  }
});

// Vote
router.post('/vote/:id', ensureAuthenticated, async (req, res) => {
  const { option } = req.body;
  try {
    const poll = await Poll.findById(req.params.id);
    poll.options = poll.options.map(o =>
      o.option === option ? { ...o, votes: o.votes + 1 } : o
    );
    await poll.save();
    res.status(200).json({ message: 'Vote recorded successfully' });
  } catch (err) {
    res.status(400).json({ error: 'Error recording vote' });
  }
});

// Fetch Polls
router.get('/', async (req, res) => {
  try {
    const polls = await Poll.find().populate('createdBy', 'username');
    res.status(200).json(polls);
  } catch (err) {
    res.status(400).json({ error: 'Error fetching polls' });
  }
});

module.exports = router;
// routes/protectedRoute.js
const express = require('express');
const router = express.Router();
const { ensureAuthenticated } = require('../middleware/auth');

router.get('/protected', ensureAuthenticated, (req, res) => {
  res.status(200).json({ message: 'You are authorized' });
});

module.exports = router;
// routes/reviews.js
const express = require('express');
const router = express.Router();
const Review = require('../models/Review');
const { ensureAuthenticated } = require('../config/auth');

// Add a new review
router.post('/add', ensureAuthenticated, async (req, res) => {
    const { businessId, rating, comment } = req.body;
    try {
        const newReview = new Review({
            business: businessId,
            user: req.user.id,
            rating,
            comment
        });
        await newReview.save();
        res.status(201).send('Review added successfully');
    } catch (error) {
        res.status(500).send('Error adding review');
    }
});

// Update a review
router.put('/update/:id', ensureAuthenticated, async (req, res) => {
    const { rating, comment } = req.body;
    try {
        await Review.findByIdAndUpdate(req.params.id, { rating, comment });
        res.status(200).send('Review updated successfully');
    } catch (error) {
        res.status(500).send('Error updating review');
    }
});

// Delete a review
router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
    try {
        await Review.findByIdAndRemove(req.params.id);
        res.status(200).send('Review deleted successfully');
    } catch (error) {
        res.status(500).send('Error deleting review');
    }
});

// Get reviews for a business
router.get('/business/:businessId', async (req, res) => {
    try {
        const reviews = await Review.find({ business: req.params.businessId }).populate('user', 'username');
        res.status(200).json(reviews);
    } catch (error) {
        res.status(500).send('Error fetching reviews');
    }
});

module.exports = router;
// routes/rsvp.js
const express = require('express');
const router = express.Router();
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const { COMMISSION_PERCENTAGE } = require('../config/commission');
const Event = require('../models/Event');
const twilio = require('twilio');
const sgMail = require('@sendgrid/mail');

const twilioClient = new twilio(process.env.TWILIO_SID, process.env.TWILIO_AUTH_TOKEN);
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

router.post('/rsvp', async (req, res) => {
    const { eventId, paymentMethodId, isPaid, ticketPrice, phoneNumber, email } = req.body;
    try {
        const event = await Event.findById(eventId).populate('organizer');
        let totalAmount = 0;
        let commission = 0;

        if (isPaid) {
            commission = (ticketPrice * COMMISSION_PERCENTAGE) / 100;
            totalAmount = ticketPrice + commission;
        }

        const paymentIntent = await stripe.paymentIntents.create({
            amount: totalAmount * 100, // in cents
            currency: 'usd',
            payment_method: paymentMethodId,
            confirm: true,
            transfer_data: isPaid ? {
                destination: event.organizer.stripeAccountId, // Assuming the organizer has a Stripe account
                amount: (ticketPrice - commission) * 100 // amount in cents
            } : {}
        });

        // Send SMS notification
        if (phoneNumber) {
            await twilioClient.messages.create({
                body: `You have successfully RSVPed for the event: ${event.title} on ${new Date(event.date).toLocaleDateString()}`,
                from: process.env.TWILIO_PHONE_NUMBER,
                to: phoneNumber
            });
        }

        // Send email notification
        if (email) {
            const msg = {
                to: email,
                from: 'noreply@countywebtools.com', // Use your verified SendGrid sender email
                subject: `RSVP Confirmation for ${event.title}`,
                text: `You have successfully RSVPed for the event: ${event.title} on ${new Date(event.date).toLocaleDateString()}`,
                html: `<strong>You have successfully RSVPed for the event: ${event.title} on ${new Date(event.date).toLocaleDateString()}</strong>`
            };
            await sgMail.send(msg);
        }

        res.status(200).send('RSVP successful');
    } catch (error) {
        res.status(500).send('Error processing RSVP');
    }
});

module.exports = router;
// routes/services.js
const express = require('express');
const router = express.Router();
const Service = require('../models/Service');

router.post('/add', async (req, res) => {
  try {
    const service = new Service(req.body);
    await service.save();
    res.status(201).json(service);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

router.get('/', async (req, res) => {
  try {
    const services = await Service.find();
    res.status(200).json(services);
  } catch (error) {
    res.status(404).json({ error: error.message });
  }
});

module.exports = router;



// routes/services.js
// const express = require('express');
// const router = express.Router();
// const Service = require('../models/Service');
// const { ensureAuthenticated } = require('../config/auth');

// // Add a new service
// router.post('/add', ensureAuthenticated, async (req, res) => {
//     const { name, description, price, duration } = req.body;
//     try {
//         const newService = new Service({
//             provider: req.user.id,
//             name,
//             description,
//             price,
//             duration
//         });
//         await newService.save();
//         res.status(201).send('Service added successfully');
//     } catch (error) {
//         res.status(500).send('Error adding service');
//     }
// });

// // Update a service
// router.put('/update/:id', ensureAuthenticated, async (req, res) => {
//     const { name, description, price, duration } = req.body;
//     try {
//         await Service.findByIdAndUpdate(req.params.id, { name, description, price, duration });
//         res.status(200).send('Service updated successfully');
//     } catch (error) {
//         res.status(500).send('Error updating service');
//     }
// });

// // Delete a service
// router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
//     try {
//         await Service.findByIdAndRemove(req.params.id);
//         res.status(200).send('Service deleted successfully');
//     } catch (error) {
//         res.status(500).send('Error deleting service');
//     }
// });

// module.exports = router;
// routes/users.js
const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const passport = require('passport');
const User = require('../models/User');

// Register Page
router.get('/register', (req, res) => res.send('Register Page'));

// Register
router.post('/register', async (req, res) => {
    const { username, password } = req.body;
    let errors = [];

    if (!username || !password) {
        errors.push({ msg: 'Please enter all fields' });
    }

    if (password.length < 6) {
        errors.push({ msg: 'Password must be at least 6 characters' });
    }

    if (errors.length > 0) {
        res.status(400).json({ errors });
    } else {
        try {
            let user = await User.findOne({ username: username });
            if (user) {
                res.status(400).json({ errors: [{ msg: 'Username already exists' }] });
            } else {
                const newUser = new User({ username, password });

                // Hash password
                bcrypt.genSalt(10, (err, salt) => {
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if (err) throw err;
                        newUser.password = hash;
                        newUser.save()
                            .then(user => res.status(201).json({ msg: 'User registered', user }))
                            .catch(err => console.log(err));
                    });
                });
            }
        } catch (err) {
            console.log(err);
            res.status(500).send('Server error');
        }
    }
});

// Login Page
router.get('/login', (req, res) => res.send('Login Page'));

// Login
router.post('/login', (req, res, next) => {
    passport.authenticate('local', {
        successRedirect: '/dashboard',
        failureRedirect: '/login',
        failureFlash: true
    })(req, res, next);
});

// Logout
router.get('/logout', (req, res) => {
    req.logout();
    res.redirect('/login');
});

module.exports = router;


// ai-toolbox
// tests/aiFunctions.test.js
const { analyzeCodeSnippet } = require('../utils/aiFunctions');

test('Analyze Code Snippet', async () => {
  const codeSnippet = `
    function multiply(a, b) {
      return a * b;
    }
    module.exports = multiply;
  `;
  const analysis = await analyzeCodeSnippet(codeSnippet);
  expect(analysis).toContain('This is a simple Node.js module which exports a function named `multiply`');
}, 15000); // Increase timeout to 15000 ms
// tests/analyzeCodeQuality.test.js
const { analyzeCodeQuality } = require('../utils/analyzeCodeQuality');
const fs = require('fs');

test('Analyze Code Quality', async () => {
  const path = require('path');
  const projectRoot = path.resolve(__dirname, '..');
  const readmeFilePath = path.join(projectRoot, 'testDir/sampleCode.js');

  const result = await analyzeCodeQuality(readmeFilePath);
  expect(result).toContain('Sample Code');
}, 10000); // Increased timeout to 10000 ms// tests/analyzeState.test.js
const { analyzeState } = require('../utils/analyzeState');
const path = require('path');

test('should analyze project state and return report', () => {
  const projectRoot = path.resolve(__dirname, '..');
  const stateReport = analyzeState(projectRoot);
  expect(stateReport).toHaveProperty('files');
  expect(stateReport).toHaveProperty('directories');
});
// tests/checkDependencies.test.js
const { checkDependencies } = require('../utils/checkDependencies');

test('Check Dependencies', () => {
  const result = checkDependencies();
  expect(result).toContain('Some dependencies are outdated');
});
// tests/codeAnalyzer.test.js
const { analyzeCode } = require('../utils/codeAnalyzer');

const fs = require('fs');

test('analyzeCode should return analysis', async () => {
  const path = require('path');
  // Define paths relative to the script's location
  const projectRoot = path.resolve(__dirname, '..');
  const readmeFilePath = path.join(projectRoot, 'testDir/sampleCode.js');
  const analysis = await analyzeCode(readmeFilePath);
  expect(analysis).toContain('Sample Code');
});

// tests/commandLogger.test.js
const fs = require('fs');
const path = require('path');
const { logCommand } = require('../utils/commandLogger');

describe('Command Logger', () => {
  const logPath = path.join(__dirname, '../command_log.txt');
  beforeAll(() => {
    if (!fs.existsSync(logPath)) {
      fs.writeFileSync(logPath, '', 'utf8');
    }
  });

  it('should log a command with a timestamp', () => {
    const command = 'git commit';
    logCommand(command);
    const logContents = fs.readFileSync(logPath, 'utf-8');
    expect(logContents).toContain(command);
  });
});
// tests/dependencyVerifier.test.js
const { verifyDependencies } = require('../utils/dependencyVerifier');
jest.mock('child_process', () => ({
  exec: jest.fn((cmd, callback) => callback(null, 'mocked output'))
}));

describe('Dependency Verifier', () => {
  it('should verify dependencies', async () => {
    const result = await verifyDependencies();
    expect(result).toEqual({
      "archiver": "^7.0.1",
      "dotenv": "^16.4.5",
      "openai": "^4.52.5",
      "postcss": "^8.4.39",
      "progress-stream": "^2.0.0",
      "react": "^17.0.2",
      "react-dom": "^17.0.2",
      "react-scripts": "^5.0.1"
    });
  });
});
// tests/directoryTraversal.test.js
const path = require('path');
const directoryTraversal = require('../utils/directoryTraversal');

test('should list all files in the directory', done => {
  const files = [];
  const expectedFileCount = 1; // Adjust based on actual file count in testDir
  const projectRoot = path.resolve(__dirname, '..');
  const expectedFilePath = path.join(projectRoot, 'testDir/sampleCode.js').replace(/\\/g, '/');

  directoryTraversal(path.join(projectRoot, 'testDir'), (err, filePath) => {
    if (err) return done(err);
    files.push(filePath.replace(/\\/g, '/'));
    if (files.length === expectedFileCount) {
      expect(files).toContain(expectedFilePath);
      done();
    }
  });
}, 80000); // Increase timeout if necessary
// File: scripts/generate-config.test.js
const fs = require('fs');
const path = require('path');
const { generateConfig } = require('../utils/generate-config');

describe('generateConfig', () => {
  const configPath = path.join(__dirname, '..', 'config/config.json');

  beforeAll(() => {
    if (fs.existsSync(configPath)) fs.unlinkSync(configPath); // Ensure file starts empty
  });

  it('should create a config file', () => {
    generateConfig();
    const configContent = fs.readFileSync(configPath, 'utf-8');
    expect(configContent).toContain('"projectName": "ai-toolbox"');
    expect(configContent).toContain('"version": "1.0.0"');
  });
});
// File: scripts/generate-state-report.test.js
const { generateStateReport } = require('../utils/generate-state-report');
const fs = require('fs');
const path = require('path');

test('generateStateReport creates a project state report', () => {
  const reportPath = path.join(__dirname, '..', 'project-state.json');
  if (fs.existsSync(reportPath)) fs.unlinkSync(reportPath); // Ensure file starts empty

  generateStateReport();

  const reportContent = fs.readFileSync(reportPath, 'utf-8');
  expect(reportContent).toContain('"timestamp"');
});
// tests/generateProjectStructure.test.js
const { generateProjectStructure } = require('../utils/generateProjectStructure');

describe('generateProjectStructure', () => {
  test('should generate project structure excluding node_modules and package-lock.json', () => {
    const structure = generateProjectStructure(process.cwd());
    expect(structure).not.toContain('node_modules');
    expect(structure).not.toContain('package-lock.json');
    expect(structure).toContain('package.json');
  });
});
// tests/gptHelper.test.js
const { gptAnalyzeCode } = require('../utils/gptHelper');

test('gptAnalyzeCode should return valid code snippet', async () => {
  const code = await gptAnalyzeCode('Create a React class component');
  expect(code).toContain('class ExampleComponent extends React.Component');
}, 10000); // Increase timeout to 10000 ms

// File: tests/sum.test.js
// Purpose: Unit test for sum function
// Description: This test checks if the sum function correctly adds two numbers.

const sum = require('../src/sum');

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
// File: utils/validateProject.test.js
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const { logCommand } = require('../utils/commandLogger');
const { validateProject } = require('../utils/validateProject');

describe('Project Validation', () => {
  const logPath = path.join(__dirname, '../command_log.txt');
  const tempDir = path.join(__dirname, '../temp_dir');

  beforeAll(() => {
    if (fs.existsSync(logPath)) {
      fs.unlinkSync(logPath);
    }
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir);
    }
    process.chdir(tempDir);
  });

  afterAll(() => {
    process.chdir(__dirname);
    fs.rmdirSync(tempDir, { recursive: true });
  });

  it('should validate the project by executing logged commands', () => {
    logCommand('npm init -y');
    logCommand('npm install jest');

    validateProject();

    const packageJsonPath = path.join(tempDir, 'package.json');
    const nodeModulesPath = path.join(tempDir, 'node_modules');

    expect(fs.existsSync(packageJsonPath)).toBe(true);
    expect(fs.existsSync(nodeModulesPath)).toBe(true);
  });
});
// tests/verifyProjectStructure.test.js
const { verifyStructure } = require('../utils/verifyProjectStructure');

test('Verify Project Structure', () => {
  const result = verifyStructure();
  expect(result).toBe('Project structure is correct');
});
// tests/virtualAssistant.test.js
const { virtualAssistant } = require('../utils/virtualAssistant');

test('should analyze all code files and suggest fixes', async () => {
  const results = await virtualAssistant();
  expect(results).not.toBeNull();
  results.forEach(result => {
    expect(result).toHaveProperty('file');
    expect(result).toHaveProperty('analysis');
  });
}, 15000); // Increase timeout to 15 seconds


// utils/aiFunctions.js
const { gptAnalyzeCode } = require('./gptHelper');

async function analyzeCodeSnippet(codeSnippet) {
  try {
    const analysis = await gptAnalyzeCode(codeSnippet);
    console.log('Code Analysis:', analysis);
    return analysis;
  } catch (error) {
    console.error('Error analyzing code snippet:', error);
    throw error;
  }
}

module.exports = { analyzeCodeSnippet };
// utils/analyzeCodeQuality.js
const { gptAnalyzeCode } = require('./gptHelper');
const fs = require('fs');

async function analyzeCodeQuality(filePath) {
  try {
    const code = fs.readFileSync(filePath, 'utf-8');
    const analysis = await gptAnalyzeCode(code);
    return analysis;
  } catch (error) {
    return `Error analyzing code quality: ${error.message}`;
  }
}

module.exports = { analyzeCodeQuality };
// File: utils/stateAnalyzer.js
// Purpose: Analyze project state and generate a report
// Description: This script scans the project directories and files, then generates a state report.

// utils/analyzeState.js
const fs = require('fs');
const path = require('path');

function analyzeState(directory) {
  const state = {
    files: [],
    directories: []
  };

  function traverse(dir) {
    const items = fs.readdirSync(dir);
    items.forEach(item => {
      const fullPath = path.join(dir, item);
      const stats = fs.statSync(fullPath);
      if (stats.isDirectory()) {
        state.directories.push(fullPath);
        traverse(fullPath);
      } else {
        state.files.push(fullPath);
      }
    });
  }

  traverse(directory);
  return state;
}

module.exports = { analyzeState };
// utils/backUpProjectFiles.js
/**
 * Compress the entire project directory.
 * Provide real-time updates on the compression progress.
 * Log errors and progress messages.
 * @param {string} directory - The root directory to verify.
 * @returns {string} - Result of the verification.
 */
const fs = require('fs');
const path = require('path');
const archiver = require('archiver');
const progress = require('progress-stream');

const dirName = 'docs'; // Only change the dirName var. Use '../' if you're going to back up the project root directory.

const zipDir = `../${dirName}`; // Which directory would you like to zip? Use -> '../' <- for root directory.
const backUpDir = '../.backup-project-files'; // Which folder you're zipping the files into
const zipName = dirName; // Name of the zip file tests.zip

// Paths
const projectDirectory = path.resolve(__dirname, zipDir); // (__dirname, '../') for root directory. Resolve project directory relative to script location
const backupDirectory = path.resolve(projectDirectory, backUpDir); // Replace with your backup path
console.log(projectDirectory);
console.log(backupDirectory);


// Ensure the backup directory exists
if (!fs.existsSync(backupDirectory)) {
    fs.mkdirSync(backupDirectory, { recursive: true });
}

// Function to generate a unique backup filename
const getUniqueBackupFileName = (baseName) => {
    let index = 0;
    let backupFile = path.join(backupDirectory, `${baseName}.zip`);
    while (fs.existsSync(backupFile)) {
        index += 1;
        backupFile = path.join(backupDirectory, `${baseName}-${index.toString().padStart(2, '0')}.zip`);
    }
    return backupFile;
};

const backupFile = getUniqueBackupFileName(zipName);

// Create a file to stream archive data to.
const output = fs.createWriteStream(backupFile);
const archive = archiver('zip', {
    zlib: { level: 9 } // Sets the compression level.
});

// Listen for all archive data to be written
output.on('close', () => {
    console.log(`Backup completed: ${archive.pointer()} total bytes`);
});

// This event is fired when the data source is drained no matter what was the data source.
// It is not part of this library but rather from the NodeJS Stream API.
output.on('end', () => {
    console.log('Data has been drained');
});

// Good practice to catch this error explicitly
archive.on('error', (err) => {
    throw err;
});

// Create progress stream
const progressStream = progress({
    length: fs.statSync(projectDirectory).size,
    time: 100 // Update every 100 ms
});

progressStream.on('progress', (progress) => {
    console.log(`Compression progress: ${Math.round(progress.percentage)}% (${(progress.transferred / (1024 * 1024)).toFixed(2)} MB transferred)`);
});

// Pipe the progress stream to the archive
archive.pipe(progressStream).pipe(output);

// Append files from the project directory
archive.directory(projectDirectory, false);

// Finalize the archive (i.e. we are done appending files but streams have to finish yet)
archive.finalize();// utils/checkDependencies.js
const { execSync } = require('child_process');

function checkDependencies() {
  try {
    execSync('npm outdated', { stdio: 'ignore' });
    return 'All dependencies are up-to-date';
  } catch (error) {
    return 'Some dependencies are outdated';
  }
}

module.exports = { checkDependencies };
// utils/codeAnalyzer.js
const fs = require('fs');
const { gptConnect } = require('./gptConnect');

async function analyzeCode(filePath) {
  const code = fs.readFileSync(filePath, 'utf-8');
  const response = await gptConnect.chat.completions.create({
    model: 'gpt-3.5-turbo',
    messages: [{ role: 'user', content: code }],
  });
  return response.choices[0].message.content;
}

module.exports = { analyzeCode };// File: utils/commandLogger.js
// Purpose: Log commands executed in the project
// Description: This utility captures and formats command logs with timestamps.

const fs = require('fs');
const path = require('path');

// Define paths relative to the script's location
const projectRoot = path.resolve(__dirname, '..');

function logCommand(command) {
  const logPath = path.join(projectRoot, 'command_log.txt');
  const timestamp = new Date().toISOString();
  fs.appendFileSync(logPath, `${timestamp}: ${command}\n`);
}

module.exports = { logCommand };
// utils/dependencyVerifier.js

// const { exec } = require('child_process');
const fs = require('fs');
const path = require('path');

function verifyDependencies() {
  const packageJsonPath = path.join(__dirname, '../package.json');
  if (!fs.existsSync(packageJsonPath)) {
    throw new Error('package.json not found');
  }

  const packageJson = require(packageJsonPath);
  const dependencies = packageJson.dependencies;
  // Add logic to verify dependencies
  return dependencies;
}

module.exports = { verifyDependencies };
// utils/directoryTraversal.js
const fs = require('fs');
const path = require('path');

function directoryTraversal(dir, callback) {
  fs.readdir(dir, (err, files) => {
    if (err) return callback(err);
    files.forEach(file => {
      const filePath = path.join(dir, file);
      fs.stat(filePath, (err, stat) => {
        if (err) return callback(err);
        if (stat.isDirectory()) {
          directoryTraversal(filePath, callback);
        } else {
          callback(null, filePath);
        }
      });
    });
  });
}

module.exports = directoryTraversal;// utils/validate.js
const { execSync } = require('child_process');
const path = require('path');

const projectRoot = path.resolve(__dirname, '..');

try {
    const eslintConfigPath = path.join(projectRoot, 'eslint.config.mjs');
    const rootDir = path.join(projectRoot, '**/*.js');
    const scriptsPath = path.join(projectRoot, 'scripts/*.js');
    const utilsPath = path.join(projectRoot, 'utils/*.js');

    const command = `npx eslint --config "${eslintConfigPath}" "${rootDir.replace(/\\/g, "/")}" "${scriptsPath.replace(/\\/g, "/")}" "${utilsPath.replace(/\\/g, "/")}"`;

    console.log(`ESLint Config Path: ${eslintConfigPath}`);
    console.log(`Root Path: ${rootDir}`);
    console.log(`Scripts Path: ${scriptsPath}`);
    console.log(`Utils Path: ${utilsPath}`);
    console.log(`Executing Command: ${command}`);

    execSync(command, { stdio: 'inherit' });
    console.log('ESLint validation completed successfully.');
} catch (error) {
    console.error('Error running ESLint:', error.message);
    process.exit(1);
}
// File: scripts/generate-config.js
// Purpose: Generate configuration files for the project
// Description: This script will create initial configuration files needed for the project setup.

const fs = require('fs');
const path = require('path');

// Define paths relative to the script's location
const projectRoot = path.resolve(__dirname, '..');
const configPath = path.join(projectRoot, 'config/config.json');

const configContent = {
  projectName: "ai-toolbox",
  version: "1.0.0"
};

function generateConfig() {
  fs.writeFileSync(configPath, JSON.stringify(configContent, null, 2));
  console.log('Configuration file generated at config/config.json');
}

module.exports = { generateConfig };
// File: scripts/generate-state-report.js
// Purpose: Analyze project state and generate a report
// Description: This script scans the project directories and files, then generates a state report containing the current status and changes in the project.

const fs = require('fs');
const path = require('path');

/**
 * Recursively scan a directory and list all files.
 * @param {string} dir - Directory to scan.
 * @returns {string[]} List of file paths.
 */
function getFiles(dir) {
  let results = [];
  const list = fs.readdirSync(dir);

  list.forEach(file => {
    file = path.resolve(dir, file);
    const stat = fs.statSync(file);
    if (stat && stat.isDirectory()) {
      results = results.concat(getFiles(file));
    } else {
      results.push(file);
    }
  });

  return results;
}

/**
 * Generate a project state report.
 */
function generateStateReport() {
  const report = {
    timestamp: new Date().toISOString(),
    // other report details
  };

  const reportPath = path.resolve(__dirname, '../project-state.json');
  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));
  console.log(`Project state report generated at ${reportPath}`);
}

module.exports = { generateStateReport };// utils/generateProjectStructure.js
// Purpose: Generate the project structure.
const fs = require('fs');
const path = require('path');

function generateProjectStructure(dir) {
  const files = fs.readdirSync(dir).filter(file => !['node_modules', 'package-lock.json'].includes(file));
  return files;
}

module.exports = { generateProjectStructure };
// utils/gptConnect.js
// require('dotenv').config();
// const { OpenAI } = require('openai');

// const openai = new OpenAI({
//     apiKey: process.env.OPENAI_API_KEY
// });

// module.exports = { openai };

// utils/gptConnect.js
// const fs = require('fs');
import 'openai/shims/node'; // Add this line
require('dotenv').config();
const { OpenAI } = require('openai');

const gptConnect = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  dangerouslyAllowBrowser: true
});

module.exports = { gptConnect };
// utils/gptHelper.js
/**
 * Analyzes the given code snippet using OpenAI's GPT-4 model.
 *
 * @param {string} code - The code snippet to analyze.
 * @returns {Promise<string>} - The analysis result from GPT-4.
 */
const fs = require('fs');
const { gptConnect } = require('./gptConnect');

async function gptAnalyzeCode(code) {
  try {
    const response = await gptConnect.chat.completions.create({
      model: "gpt-4",
      messages: [
        {
          role: "system",
          content: "You are a helpful assistant that analyzes code."
        },
        {
          role: "user",
          content: `Analyze this code:\n\n${code}`
        }
      ],
      max_tokens: 150
    });
    return response.choices[0].message.content.trim();
  } catch (error) {
    console.error('Error analyzing code:', error);
    throw error;
  }
}

module.exports = { gptAnalyzeCode };
// File: utils/nextStep.js
// Purpose: Generate next steps using GPT
// Description: This script generates the next steps for the project based on the current state and history.

const { generateProjectPlan } = require('./gptHelper');

async function nextStep() {
  const plan = await generateProjectPlan('Generate next steps for my project...');
  console.log(plan);
}

nextStep();
// utils/projectVerifier.js
const fs = require('fs');
const path = require('path');
const exec = require('child_process').exec;
const { gptAnalyzeCode } = require('./gptHelper');

function verifyProjectStructure() {
  const expectedStructure = [
    'package.json',
    'jest.config.js',
    'src/',
    'tests/',
    'utils/',
  ];

  expectedStructure.forEach((item) => {
    if (!fs.existsSync(path.join(__dirname, '..', item))) {
      console.error(`Missing ${item}`);
    } else {
      console.log(`${item} exists`);
    }
  });
}

function verifyDependencies() {
  exec('npm ls', (err, stdout, stderr) => {
    if (err) {
      console.error('Error in verifying dependencies:', stderr);
    } else {
      console.log('Dependencies verified:', stdout);
    }
  });
}

function runTests() {
  exec('npm test', (err, stdout, stderr) => {
    if (err) {
      console.error('Tests failed:', stderr);
    } else {
      console.log('Test results:', stdout);
    }
  });
}

function analyzeCode() {
  const filesToAnalyze = [
    path.join(__dirname, '..', 'src', 'index.js'),
    path.join(__dirname, '..', 'utils', 'commandLogger.js'),
    // Add more files as needed
  ];

  filesToAnalyze.forEach((file) => {
    const code = fs.readFileSync(file, 'utf-8');
    gptAnalyzeCode(code).then((analysis) => {
      console.log(`Analysis for ${file}: ${analysis}`);
    });
  });
}

module.exports = { verifyProjectStructure, verifyDependencies, runTests, analyzeCode };
// File: utils/taskRunner.js
// Purpose: Run automated tasks such as tests
// Description: This script uses child processes to run tasks and logs the results.

const { exec } = require('child_process');

function runTests() {
  exec('npm test', (err, stdout, stderr) => {
    if (err) {
      console.error(`Error: ${stderr}`);
      return;
    }
    console.log(`Results: ${stdout}`);
  });
}

module.exports = { runTests };
// utils/testApiConnection.js
// const { openai } = require('./gptConnect');
const fs = require('fs');
const { gptAnalyzeCode } = require('./gptHelper');

async function testConnection() {
  try {
    const codeSnippet = `
    function add(a, b) {
      return a + b;
    }
    module.exports = add;
    `;
    const analysis = await gptAnalyzeCode(codeSnippet);
    console.log('API Connection Successful:', analysis);
  } catch (error) {
    console.error('API Connection Failed:', error);
  }
}

testConnection();
// File: utils/validateProject.js
// Purpose: Validate project by re-executing logged commands
// Description: This script reads the command log, re-executes commands, and ensures project consistency.

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

// Define paths relative to the script's location
const projectRoot = path.resolve(__dirname, '..');

const LOG_FILE = path.join(projectRoot, 'command_log.txt');
const TEMP_DIR = path.join(projectRoot, 'temp_dir');

if (!fs.existsSync(LOG_FILE)) {
  console.error('command_log.txt not found!');
  process.exit(1);
}

if (!fs.existsSync(TEMP_DIR)) {
  fs.mkdirSync(TEMP_DIR);
}

process.chdir(TEMP_DIR);

const logData = fs.readFileSync(LOG_FILE, 'utf-8');
const logLines = logData.split('\n');

logLines.forEach(line => {
  const commandMatch = line.match(/Command: (.*) \| Outcome:/);
  if (commandMatch) {
    const command = commandMatch[1];
    if (command) {
      console.log(`Executing: ${command}`);
      try {
        execSync(command, { stdio: 'inherit' });
      } catch (error) {
        console.error(`Error executing command: ${command}`);
      }
    }
  }
});

process.chdir(__dirname);
fs.rmSync(TEMP_DIR, { recursive: true, force: true });

console.log('Project validation completed successfully.');
// utils/verifyProjectStructure.js
/**
 * Verifies that the project structure matches the expected layout.
 *
 * @param {string} directory - The root directory to verify.
 * @returns {string} - Result of the verification.
 */
const fs = require('fs');
const path = require('path');

const expectedStructure = {
  'package.json': 'file',
  'utils': 'directory',
  'tests': 'directory',
  'scripts': 'directory',
  // Add more expected files and directories here
};

function verifyStructure(directory = '.') {
  for (const [name, type] of Object.entries(expectedStructure)) {
    const fullPath = path.join(directory, name);
    if (!fs.existsSync(fullPath)) {
      return `Missing ${type}: ${name}`;
    }
    const stat = fs.statSync(fullPath);
    if ((type === 'file' && !stat.isFile()) || (type === 'directory' && !stat.isDirectory())) {
      return `Expected ${name} to be a ${type}, but it's not`;
    }
  }
  return 'Project structure is correct';
}

module.exports = { verifyStructure };
// utils/virtualAssistant.js
// const { traverseDirectory } = require('./directoryTraversal');
// const { verifyDependencies } = require('./dependencyVerifier');
// const { analyzeCode } = require('./codeAnalyzer');
// const { analyzeCodeQuality } = require('./analyzeCodeQuality');
// const fs = require('fs');
// const path = require('path');
// utils/virtualAssistant.js
const { analyzeCode } = require('./codeAnalyzer');
const fs = require('fs');
const path = require('path');
const gptConnect = require('./gptConnect');

async function virtualAssistant() {
  try {
    const dirPath = path.resolve(__dirname, '../testDir');
    const files = fs.readdirSync(dirPath).filter(file => file.endsWith('.js'));
    const results = await Promise.all(files.map(file => analyzeCode(path.join(dirPath, file))));
    return results.map((analysis, index) => ({ file: files[index], analysis }));
  } catch (error) {
    console.error('Error in Virtual Assistant:', error);
    return null;
  }
}

module.exports = { virtualAssistant };





// async function virtualAssistant() {
//   try {
//     const projectRoot = path.resolve(__dirname, '..');
//     const utilsPath = path.join(projectRoot, 'utils');
//     const testsPath = path.join(projectRoot, 'tests');
//     const scriptsPath = path.join(projectRoot, 'scripts');

//     const files = [
//       ...fs.readdirSync(utilsPath).map(file => path.join(utilsPath, file)),
//       ...fs.readdirSync(testsPath).map(file => path.join(testsPath, file)),
//       ...fs.readdirSync(scriptsPath).map(file => path.join(scriptsPath, file)),
//     ];

//     const results = await Promise.all(files.map(async (file) => {
//       const content = fs.readFileSync(file, 'utf-8');
//       const analysis = await analyzeCodeQuality(file);
//       return { file, analysis };
//     }));

//     return results;
//   } catch (error) {
//     console.error('Error in Virtual Assistant:', error);
//     return null;
//   }
// }

// module.exports = { virtualAssistant };


// async function virtualAssistant() {
//   try {
//     const files = await traverseDirectory(process.cwd());
//     console.log('Files:', files);

//     const depsStatus = await verifyDependencies();
//     console.log('Dependencies Status:', depsStatus);

//     const assessCode = await analyzeCode(files);
//     console.log('Code Assessment:', assessCode);

//     const codeQuality = await analyzeCodeQuality(files);
//     console.log('Code Quality:', codeQuality);

//     return { files, depsStatus, assessCode, codeQuality };
//   } catch (error) {
//     console.error('Error in Virtual Assistant:', error);
//   }
// }

// module.exports = { virtualAssistant };


// client/src/components/*.css
import React from 'react';

const About = () => {
  return (
    <div>
      <h1>About</h1>
    </div>
  );
};

export default About;
// client/src/components/BusinessForm.js
import React, { useState } from 'react';
import axios from 'axios';

function BusinessForm() {
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [category, setCategory] = useState('');
    const [address, setAddress] = useState('');
    const [contactInfo, setContactInfo] = useState('');
    const [hours, setHours] = useState('');
    const [isFeatured, setIsFeatured] = useState(false);

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/businesses/add', { name, description, category, address, contactInfo, hours, isFeatured });
            alert('Business added successfully');
        } catch (error) {
            alert('Error adding business');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Business</h1>
            <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Business Name" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="text" value={category} onChange={(e) => setCategory(e.target.value)} placeholder="Category" required />
            <input type="text" value={address} onChange={(e) => setAddress(e.target.value)} placeholder="Address" required />
            <input type="text" value={contactInfo} onChange={(e) => setContactInfo(e.target.value)} placeholder="Contact Info" required />
            <input type="text" value={hours} onChange={(e) => setHours(e.target.value)} placeholder="Hours of Operation" required />
            <label>
                <input type="checkbox" checked={isFeatured} onChange={(e) => setIsFeatured(e.target.checked)} />
                Featured Listing
            </label>
            <button type="submit">Add Business</button>
        </form>
    );
}

export default BusinessForm;
// client/src/components/BusinessList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function BusinessList() {
    const [businesses, setBusinesses] = useState([]);

    useEffect(() => {
        axios.get('/api/businesses/all')
            .then(response => setBusinesses(response.data))
            .catch(error => console.error('Error fetching businesses:', error));
    }, []);

    return (
        <div>
            <h1>Business Directory</h1>
            <ul>
                {businesses.map(business => (
                    <li key={business._id}>
                        <h2>{business.name}</h2>
                        <p>{business.description}</p>
                        <p>Category: {business.category}</p>
                        <p>Address: {business.address}</p>
                        <p>Contact Info: {business.contactInfo}</p>
                        <p>Hours: {business.hours}</p>
                        <p>Owner: {business.owner.username}</p>
                        {business.isFeatured && <p>Featured Listing</p>}
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default BusinessList;
import React from 'react';

const Contact = () => {
  return (
    <div>
      <h1>Contact</h1>
    </div>
  );
};

export default Contact;
// client/src/components/CreatePoll.js
import React, { useState } from 'react';

const CreatePoll = () => {
  const [question, setQuestion] = useState('');
  const [options, setOptions] = useState(['', '']);

  const handleOptionChange = (index, value) => {
    const newOptions = [...options];
    newOptions[index] = value;
    setOptions(newOptions);
  };

  const addOption = () => {
    setOptions([...options, '']);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Implement API call to create poll
  };

  return (
    <form onSubmit={handleSubmit}>
      <div>
        <label>Question</label>
        <input type="text" value={question} onChange={(e) => setQuestion(e.target.value)} required />
      </div>
      <div>
        <label>Options</label>
        {options.map((option, index) => (
          <input key={index} type="text" value={option} onChange={(e) => handleOptionChange(index, e.target.value)} required />
        ))}
        <button type="button" onClick={addOption}>Add Option</button>
      </div>
      <button type="submit">Create Poll</button>
    </form>
  );
};

export default CreatePoll;
// client/src/components/Dashboard.js
import React from 'react';

function Dashboard() {
    return (
        <div>
            <h1>Dashboard</h1>
            <p>Welcome to your dashboard</p>
        </div>
    );
}

export default Dashboard;
// client/src/components/EventForm.js
import React, { useState } from 'react';
import axios from 'axios';

function EventForm() {
    const [title, setTitle] = useState('');
    const [description, setDescription] = useState('');
    const [date, setDate] = useState('');
    const [time, setTime] = useState('');
    const [location, setLocation] = useState('');
    const [isRecurring, setIsRecurring] = useState(false);
    const [category, setCategory] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/events/add', { title, description, date, time, location, isRecurring, category });
            alert('Event added successfully');
        } catch (error) {
            alert('Error adding event');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Event</h1>
            <input type="text" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="Event Title" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="date" value={date} onChange={(e) => setDate(e.target.value)} required />
            <input type="time" value={time} onChange={(e) => setTime(e.target.value)} required />
            <input type="text" value={location} onChange={(e) => setLocation(e.target.value)} placeholder="Location" required />
            <label>
                <input type="checkbox" checked={isRecurring} onChange={(e) => setIsRecurring(e.target.checked)} />
                Recurring Event
            </label>
            <input type="text" value={category} onChange={(e) => setCategory(e.target.value)} placeholder="Category" required />
            <button type="submit">Add Event</button>
        </form>
    );
}

export default EventForm;
// client/src/components/EventList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function EventList() {
    const [events, setEvents] = useState([]);

    useEffect(() => {
        axios.get('/api/events/all')
            .then(response => setEvents(response.data))
            .catch(error => console.error('Error fetching events:', error));
    }, []);

    return (
        <div>
            <h1>Upcoming Events</h1>
            <ul>
                {events.map(event => (
                    <li key={event._id}>
                        <h2>{event.title}</h2>
                        <p>{event.description}</p>
                        <p>Date: {new Date(event.date).toLocaleDateString()}</p>
                        <p>Time: {event.time}</p>
                        <p>Location: {event.location}</p>
                        <p>Category: {event.category}</p>
                        <p>Organizer: {event.organizer.username}</p>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default EventList;
// client/src/components/Features.js
import React from 'react';
import './Features.css';

const Features = () => {
  return (
    <section id="features" className="features">
      <div className="container">
        <h2 className="section-title">Features</h2>
        <div className="features-grid">
          <div className="feature-item">
            <h3>Feature 1</h3>
            <p>Description of feature 1.</p>
          </div>
          <div className="feature-item">
            <h3>Feature 2</h3>
            <p>Description of feature 2.</p>
          </div>
          <div className="feature-item">
            <h3>Feature 3</h3>
            <p>Description of feature 3.</p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default Features;
// client/src/components/Footer.js
import React from 'react';
import './Footer.css';

const Footer = () => {
  return (
    <footer className="footer">
      <div className="container">
        <p>&copy; 2024 County Web Tools. All rights reserved.</p>
        <div className="footer-links">
          <a href="#privacy">Privacy Policy</a>
          <a href="#terms">Terms of Service</a>
        </div>
      </div>
    </footer>
  );
};

export default Footer;
// client/src/components/Hero.js
import React from 'react';
import './Hero.css';

const Hero = () => {
  return (
    <section className="hero">
      <div className="hero-content">
        <h1 className="hero-title">Welcome to Our Service</h1>
        <p className="hero-subtitle">We help you manage your projects efficiently.</p>
        <div className="hero-buttons">
          <a href="#signup" className="hero-button">Get Started</a>
          <a href="#learn-more" className="hero-button secondary">Learn More</a>
        </div>
      </div>
    </section>
  );
};

export default Hero;
import React, { useEffect, useState } from 'react';

const Home = () => {
  const [data, setData] = useState([]);

  useEffect(() => {
    fetch('/api/services')
      .then(response => response.json())
      .then(data => setData(data))
      .catch(error => console.error('Error fetching data:', error));
  }, []);

  return (
    <div>
      <h1>Home</h1>
      <ul>
        {data.map(service => (
          <li key={service.id}>{service.name}</li>
        ))}
      </ul>
    </div>
  );
};

export default Home;
// client/src/components/Login.js
import React, { useState } from 'react';
import axios from 'axios';

function Login() {
    const [username, setUsername] = useState('');
    const [password, setPassword] = useState('');

    const handleLogin = async () => {
        try {
            await axios.post('http://localhost:3000/login', { username, password });
            alert('User logged in successfully');
        } catch (error) {
            alert(error.message);
        }
    };

    return (
        <div>
            <h1>Login</h1>
            <input
                type="text"
                value={username}
                onChange={(e) => setUsername(e.target.value)}
                placeholder="Username"
            />
            <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="Password"
            />
            <button onClick={handleLogin}>Login</button>
        </div>
    );
}

export default Login;
// client/src/components/Navbar.js
import React from 'react';
import './Navbar.css';

const Navbar = () => {
  return (
    <nav className="navbar">
      <div className="navbar-container">
        <a href="/" className="navbar-logo">Logo</a>
        <ul className="navbar-menu">
          <li className="navbar-item"><a href="#features" className="navbar-link">Features</a></li>
          <li className="navbar-item"><a href="#testimonials" className="navbar-link">Testimonials</a></li>
          <li className="navbar-item"><a href="#contact" className="navbar-link">Contact</a></li>
          <li className="navbar-item"><a href="#signup" className="navbar-link navbar-link-cta">Sign Up</a></li>
        </ul>
      </div>
    </nav>
  );
};

export default Navbar;import React from 'react';

const NotFound = () => {
  return (
    <div>
      <h1>404 Not Found</h1>
    </div>
  );
};

export default NotFound;
// client/src/components/Polls.js
import React, { useEffect, useState } from 'react';

const Polls = () => {
  const [polls, setPolls] = useState([]);

  useEffect(() => {
    // Fetch polls from the backend
  }, []);

  return (
    <div>
      <h1>Polls</h1>
      {polls.map(poll => (
        <div key={poll.id}>
          <h2>{poll.question}</h2>
          <ul>
            {poll.options.map(option => (
              <li key={option.option}>
                {option.option}: {option.votes} votes
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
};

export default Polls;
// client/src/components/Register.js
import React, { useState } from 'react';
import axios from 'axios';

function Register() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      await axios.post('/api/register', { username, password });
      alert('User registered successfully!');
    } catch (error) {
      alert('Error registering user');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <input
        type="text"
        name="username"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        placeholder="Username"
      />
      <input
        type="password"
        name="password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        placeholder="Password"
      />
      <button type="submit">Register</button>
    </form>
  );
}

export default Register;
// client/src/components/ReviewForm.js
import React, { useState } from 'react';
import axios from 'axios';

function ReviewForm({ businessId }) {
    const [rating, setRating] = useState(1);
    const [comment, setComment] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/reviews/add', { businessId, rating, comment });
            alert('Review added successfully');
        } catch (error) {
            alert('Error adding review');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a Review</h1>
            <label>
                Rating:
                <select value={rating} onChange={(e) => setRating(e.target.value)}>
                    {[1, 2, 3, 4, 5].map(num => (
                        <option key={num} value={num}>{num}</option>
                    ))}
                </select>
            </label>
            <textarea value={comment} onChange={(e) => setComment(e.target.value)} placeholder="Comment" required />
            <button type="submit">Add Review</button>
        </form>
    );
}

export default ReviewForm;
// client/src/components/ReviewList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ReviewList({ businessId }) {
    const [reviews, setReviews] = useState([]);

    useEffect(() => {
        axios.get(`/api/reviews/business/${businessId}`)
            .then(response => setReviews(response.data))
            .catch(error => console.error('Error fetching reviews:', error));
    }, [businessId]);

    return (
        <div>
            <h1>Reviews</h1>
            <ul>
                {reviews.map(review => (
                    <li key={review._id}>
                        <h2>{review.user.username}</h2>
                        <p>Rating: {review.rating}</p>
                        <p>{review.comment}</p>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default ReviewList;
// client/src/components/ServiceForm.js
import React, { useState } from 'react';
import axios from 'axios';

function ServiceForm() {
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [price, setPrice] = useState('');
    const [duration, setDuration] = useState('');

    const handleSubmit = async (e) => {
        e.preventDefault();
        try {
            await axios.post('/api/services/add', { name, description, price, duration });
            alert('Service added successfully');
        } catch (error) {
            alert('Error adding service');
        }
    };

    return (
        <form onSubmit={handleSubmit}>
            <h1>Add a New Service</h1>
            <input type="text" value={name} onChange={(e) => setName(e.target.value)} placeholder="Service Name" required />
            <textarea value={description} onChange={(e) => setDescription(e.target.value)} placeholder="Description" required />
            <input type="number" value={price} onChange={(e) => setPrice(e.target.value)} placeholder="Price" required />
            <input type="number" value={duration} onChange={(e) => setDuration(e.target.value)} placeholder="Duration (minutes)" required />
            <button type="submit">Add Service</button>
        </form>
    );
}

export default ServiceForm;
// client/src/components/ServiceList.js
import React, { useState, useEffect } from 'react';
import axios from 'axios';

function ServiceList() {
    const [services, setServices] = useState([]);

    useEffect(() => {
        axios.get('/api/services')
            .then(response => setServices(response.data))
            .catch(error => console.error('Error fetching services:', error));
    }, []);

    return (
        <div>
            <h1>Available Services</h1>
            <ul>
                {services.map(service => (
                    <li key={service._id}>
                        <h2>{service.name}</h2>
                        <p>{service.description}</p>
                        <p>Price: ${service.price}</p>
                        <p>Duration: {service.duration} minutes</p>
                        <button>Book Now</button>
                    </li>
                ))}
            </ul>
        </div>
    );
}

export default ServiceList;
import React from 'react';

const Services = () => {
  return (
    <div>
      <h1>Services</h1>
    </div>
  );
};

export default Services;
// client/src/components/Testimonials.js
import React from 'react';
import './Testimonials.css';

const Testimonials = () => {
  return (
    <section id="testimonials" className="testimonials">
      <div className="container">
        <h2 className="section-title">Testimonials</h2>
        <div className="testimonials-grid">
          <div className="testimonial-item">
            <p>"This service is amazing!" - User 1</p>
          </div>
          <div className="testimonial-item">
            <p>"Highly recommend to everyone." - User 2</p>
          </div>
          <div className="testimonial-item">
            <p>"Changed my life for the better." - User 3</p>
          </div>
        </div>
      </div>
    </section>
  );
};

export default Testimonials;
// client/src/components/ThemeToggle.js
import React, { useState, useEffect } from 'react';

const ThemeToggle = () => {
  const [theme, setTheme] = useState('light');

  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
  }, [theme]);

  const toggleTheme = () => {
    setTheme(theme === 'light' ? 'dark' : 'light');
  };

  return <button onClick={toggleTheme}>Toggle Theme</button>;
};

export default ThemeToggle;

//server/src/config/*.js

// config/auth.js

module.exports = {
  ensureAuthenticated: function (req, res, next) {
    if (req.isAuthenticated()) {
      return next();
    }
    res.redirect('/login');
  },
  forwardAuthenticated: function (req, res, next) {
    if (!req.isAuthenticated()) {
      return next();
    }
    res.redirect('/dashboard');      
  }
};
// config/commission.js
module.exports = {
    COMMISSION_PERCENTAGE: process.env.COMMISSION_PERCENTAGE || 10
};
// config/passport.js
const LocalStrategy = require('passport-local').Strategy;
const mongoose = require('mongoose');
const User = require('../models/User');

module.exports = function(passport) {
  passport.use(
    new LocalStrategy({ usernameField: 'email' }, (email, password, done) => {
      User.findOne({ email: email.toLowerCase() }, (err, user) => {
        if (err) return done(err);
        if (!user) {
          return done(null, false, { message: 'No user found with that email' });
        }
        user.matchPassword(password, (err, isMatch) => {
          if (err) return done(err);
          if (isMatch) {
            return done(null, user);
          } else {
            return done(null, false, { message: 'Password incorrect' });
          }
        });
      });
    })
  );

  passport.serializeUser((user, done) => {
    done(null, user.id);
  });

  passport.deserializeUser((id, done) => {
    User.findById(id, (err, user) => {
      done(err, user);
    });
  });
};

// server/src/middleware/*.js

module.exports = {
  ensureAuthenticated: (req, res, next) => {
    if (req.isAuthenticated()) {
      return next();
    }
    res.status(401).json({ error: 'Unauthorized' });
  }
};


// server/src/models/*.js

// models/Business.js
const mongoose = require('mongoose');

const businessSchema = new mongoose.Schema({
    owner: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    name: { type: String, required: true },
    description: { type: String, required: true },
    category: { type: String, required: true },
    address: { type: String, required: true },
    contactInfo: { type: String, required: true },
    hours: { type: String, required: true },
    isFeatured: { type: Boolean, default: false },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Business', businessSchema);
// models/Event.js
const mongoose = require('mongoose');

const eventSchema = new mongoose.Schema({
    title: { type: String, required: true },
    description: { type: String, required: true },
    date: { type: Date, required: true },
    time: { type: String, required: true },
    location: { type: String, required: true },
    organizer: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    isRecurring: { type: Boolean, default: false },
    category: { type: String, required: true },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Event', eventSchema);
// models/Review.js
const mongoose = require('mongoose');

const reviewSchema = new mongoose.Schema({
    business: { type: mongoose.Schema.Types.ObjectId, ref: 'Business', required: true },
    user: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
    rating: { type: Number, required: true, min: 1, max: 5 },
    comment: { type: String, required: true },
    createdAt: { type: Date, default: Date.now }
});

module.exports = mongoose.model('Review', reviewSchema);
// models/Service.js
const mongoose = require('mongoose');

const serviceSchema = new mongoose.Schema({
  name: { type: String, required: true },
  description: { type: String, required: true },
  provider: { type: String, required: true },
  duration: { type: Number, required: true },
  price: { type: Number, required: true }
});

const Service = mongoose.model('Service', serviceSchema);

module.exports = Service;
// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const UserSchema = new mongoose.Schema({
  username: {
    type: String,
    required: true,
    unique: true
  },
  email: {
    type: String,
    required: true,
    unique: true
  },
  password: {
    type: String,
    required: true
  },
  date: {
    type: Date,
    default: Date.now
  }
});

UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) {
    return next();
  }
  const salt = await bcrypt.genSalt(10);
  this.password = await bcrypt.hash(this.password, salt);
  next();
});

UserSchema.methods.matchPassword = async function(password) {
  return await bcrypt.compare(password, this.password);
};

module.exports = mongoose.model('User', UserSchema);

// server/src/routes/*.js

// routes/auth.js
const express = require('express');
const router = express.Router();
const passport = require('passport');
const User = require('../models/User');

// Register
router.post('/register', async (req, res) => {
  const { username, email, password } = req.body;
  try {
    const user = new User({ username, email, password });
    await user.save();
    res.status(201).json({ message: 'User registered successfully' });
  } catch (err) {
    res.status(400).json({ error: 'Error registering user' });
  }
});

// Login
router.post('/login', (req, res, next) => {
  passport.authenticate('local', (err, user, info) => {
    if (err) return next(err);
    if (!user) return res.status(400).json({ error: 'Invalid credentials' });
    req.logIn(user, (err) => {
      if (err) return next(err);
      res.status(200).json({ message: 'Logged in successfully' });
    });
  })(req, res, next);
});

// Logout
router.get('/logout', (req, res) => {
  req.logout((err) => {
    if (err) return res.status(500).json({ error: 'Error logging out' });
    res.status(200).json({ message: 'Logged out successfully' });
  });
});

module.exports = router;
// routes/businesses.js
const express = require('express');
const router = express.Router();
const Business = require('../models/Business');
const { ensureAuthenticated } = require('../config/auth');

// Add a new business listing
router.post('/add', ensureAuthenticated, async (req, res) => {
    const { name, description, category, address, contactInfo, hours, isFeatured } = req.body;
    try {
        const newBusiness = new Business({
            owner: req.user.id,
            name,
            description,
            category,
            address,
            contactInfo,
            hours,
            isFeatured
        });
        await newBusiness.save();
        res.status(201).send('Business added successfully');
    } catch (error) {
        res.status(500).send('Error adding business');
    }
});

// Update a business listing
router.put('/update/:id', ensureAuthenticated, async (req, res) => {
    const { name, description, category, address, contactInfo, hours, isFeatured } = req.body;
    try {
        await Business.findByIdAndUpdate(req.params.id, { name, description, category, address, contactInfo, hours, isFeatured });
        res.status(200).send('Business updated successfully');
    } catch (error) {
        res.status(500).send('Error updating business');
    }
});

// Delete a business listing
router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
    try {
        await Business.findByIdAndRemove(req.params.id);
        res.status(200).send('Business deleted successfully');
    } catch (error) {
        res.status(500).send('Error deleting business');
    }
});

// Get all business listings
router.get('/all', async (req, res) => {
    try {
        const businesses = await Business.find().populate('owner', 'username');
        res.status(200).json(businesses);
    } catch (error) {
        res.status(500).send('Error fetching businesses');
    }
});

module.exports = router;
// routes/events.js
const express = require('express');
const router = express.Router();
const Event = require('../models/Event');
const { ensureAuthenticated } = require('../config/auth');

// Add a new event
router.post('/add', ensureAuthenticated, async (req, res) => {
    const { title, description, date, time, location, isRecurring, category } = req.body;
    try {
        const newEvent = new Event({
            title,
            description,
            date,
            time,
            location,
            isRecurring,
            category,
            organizer: req.user.id
        });
        await newEvent.save();
        res.status(201).send('Event added successfully');
    } catch (error) {
        res.status(500).send('Error adding event');
    }
});

// Update an event
router.put('/update/:id', ensureAuthenticated, async (req, res) => {
    const { title, description, date, time, location, isRecurring, category } = req.body;
    try {
        await Event.findByIdAndUpdate(req.params.id, { title, description, date, time, location, isRecurring, category });
        res.status(200).send('Event updated successfully');
    } catch (error) {
        res.status(500).send('Error updating event');
    }
});

// Delete an event
router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
    try {
        await Event.findByIdAndRemove(req.params.id);
        res.status(200).send('Event deleted successfully');
    } catch (error) {
        res.status(500).send('Error deleting event');
    }
});

// Get all events
router.get('/all', async (req, res) => {
    try {
        const events = await Event.find().populate('organizer', 'username');
        res.status(200).json(events);
    } catch (error) {
        res.status(500).send('Error fetching events');
    }
});

module.exports = router;
// routes/payments.js
const express = require('express');
const router = express.Router();
const fetch = require('node-fetch'); // Use CommonJS syntax
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY, {
  httpClient: require('stripe').createFetchHttpClient(fetch), // Provide fetch implementation
});

const { COMMISSION_PERCENTAGE } = require('../config/commission');
const Service = require('../models/Service');

// Route for booking a service and processing the payment
router.post('/book', async (req, res) => {
  const { serviceId, paymentMethodId } = req.body;
  try {
    const service = await Service.findById(serviceId).populate('provider');
    const commission = (service.price * COMMISSION_PERCENTAGE) / 100;
    const totalAmount = service.price + commission;

    const paymentIntent = await stripe.paymentIntents.create({
      amount: totalAmount * 100, // in cents
      currency: 'usd',
      payment_method: paymentMethodId,
      confirm: true,
      transfer_data: {
        destination: service.provider.stripeAccountId, // Assuming the provider has a Stripe account
        amount: (service.price - commission) * 100 // amount in cents
      }
    });

    res.status(200).send('Payment successful');
  } catch (error) {
    res.status(500).send('Error processing payment');
  }
});

router.post('/create-payment-intent', async (req, res) => {
  const { amount, currency } = req.body;

  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency,
      payment_method_types: ['card']
    });

    res.status(200).send({
      clientSecret: paymentIntent.client_secret
    });
  } catch (err) {
    res.status(500).send({ error: err.message });
  }
});

module.exports = router;
// routes/polls.js
const express = require('express');
const router = express.Router();
const Poll = require('../models/Poll');
const { ensureAuthenticated } = require('../middleware/auth');

// Create Poll
router.post('/create', ensureAuthenticated, async (req, res) => {
  const { question, options } = req.body;
  try {
    const poll = new Poll({ question, options, createdBy: req.user.id });
    await poll.save();
    res.status(201).json({ message: 'Poll created successfully' });
  } catch (err) {
    res.status(400).json({ error: 'Error creating poll' });
  }
});

// Vote
router.post('/vote/:id', ensureAuthenticated, async (req, res) => {
  const { option } = req.body;
  try {
    const poll = await Poll.findById(req.params.id);
    poll.options = poll.options.map(o =>
      o.option === option ? { ...o, votes: o.votes + 1 } : o
    );
    await poll.save();
    res.status(200).json({ message: 'Vote recorded successfully' });
  } catch (err) {
    res.status(400).json({ error: 'Error recording vote' });
  }
});

// Fetch Polls
router.get('/', async (req, res) => {
  try {
    const polls = await Poll.find().populate('createdBy', 'username');
    res.status(200).json(polls);
  } catch (err) {
    res.status(400).json({ error: 'Error fetching polls' });
  }
});

module.exports = router;
// routes/protectedRoute.js
const express = require('express');
const router = express.Router();
const { ensureAuthenticated } = require('../middleware/auth');

router.get('/protected', ensureAuthenticated, (req, res) => {
  res.status(200).json({ message: 'You are authorized' });
});

module.exports = router;
// routes/reviews.js
const express = require('express');
const router = express.Router();
const Review = require('../models/Review');
const { ensureAuthenticated } = require('../config/auth');

// Add a new review
router.post('/add', ensureAuthenticated, async (req, res) => {
    const { businessId, rating, comment } = req.body;
    try {
        const newReview = new Review({
            business: businessId,
            user: req.user.id,
            rating,
            comment
        });
        await newReview.save();
        res.status(201).send('Review added successfully');
    } catch (error) {
        res.status(500).send('Error adding review');
    }
});

// Update a review
router.put('/update/:id', ensureAuthenticated, async (req, res) => {
    const { rating, comment } = req.body;
    try {
        await Review.findByIdAndUpdate(req.params.id, { rating, comment });
        res.status(200).send('Review updated successfully');
    } catch (error) {
        res.status(500).send('Error updating review');
    }
});

// Delete a review
router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
    try {
        await Review.findByIdAndRemove(req.params.id);
        res.status(200).send('Review deleted successfully');
    } catch (error) {
        res.status(500).send('Error deleting review');
    }
});

// Get reviews for a business
router.get('/business/:businessId', async (req, res) => {
    try {
        const reviews = await Review.find({ business: req.params.businessId }).populate('user', 'username');
        res.status(200).json(reviews);
    } catch (error) {
        res.status(500).send('Error fetching reviews');
    }
});

module.exports = router;
// routes/rsvp.js
const express = require('express');
const router = express.Router();
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);
const { COMMISSION_PERCENTAGE } = require('../config/commission');
const Event = require('../models/Event');
const twilio = require('twilio');
const sgMail = require('@sendgrid/mail');

const twilioClient = new twilio(process.env.TWILIO_SID, process.env.TWILIO_AUTH_TOKEN);
sgMail.setApiKey(process.env.SENDGRID_API_KEY);

router.post('/rsvp', async (req, res) => {
    const { eventId, paymentMethodId, isPaid, ticketPrice, phoneNumber, email } = req.body;
    try {
        const event = await Event.findById(eventId).populate('organizer');
        let totalAmount = 0;
        let commission = 0;

        if (isPaid) {
            commission = (ticketPrice * COMMISSION_PERCENTAGE) / 100;
            totalAmount = ticketPrice + commission;
        }

        const paymentIntent = await stripe.paymentIntents.create({
            amount: totalAmount * 100, // in cents
            currency: 'usd',
            payment_method: paymentMethodId,
            confirm: true,
            transfer_data: isPaid ? {
                destination: event.organizer.stripeAccountId, // Assuming the organizer has a Stripe account
                amount: (ticketPrice - commission) * 100 // amount in cents
            } : {}
        });

        // Send SMS notification
        if (phoneNumber) {
            await twilioClient.messages.create({
                body: `You have successfully RSVPed for the event: ${event.title} on ${new Date(event.date).toLocaleDateString()}`,
                from: process.env.TWILIO_PHONE_NUMBER,
                to: phoneNumber
            });
        }

        // Send email notification
        if (email) {
            const msg = {
                to: email,
                from: 'noreply@countywebtools.com', // Use your verified SendGrid sender email
                subject: `RSVP Confirmation for ${event.title}`,
                text: `You have successfully RSVPed for the event: ${event.title} on ${new Date(event.date).toLocaleDateString()}`,
                html: `<strong>You have successfully RSVPed for the event: ${event.title} on ${new Date(event.date).toLocaleDateString()}</strong>`
            };
            await sgMail.send(msg);
        }

        res.status(200).send('RSVP successful');
    } catch (error) {
        res.status(500).send('Error processing RSVP');
    }
});

module.exports = router;
// routes/services.js
const express = require('express');
const router = express.Router();
const Service = require('../models/Service');

router.post('/add', async (req, res) => {
  try {
    const service = new Service(req.body);
    await service.save();
    res.status(201).json(service);
  } catch (error) {
    res.status(400).json({ error: error.message });
  }
});

router.get('/', async (req, res) => {
  try {
    const services = await Service.find();
    res.status(200).json(services);
  } catch (error) {
    res.status(404).json({ error: error.message });
  }
});

module.exports = router;



// routes/services.js
// const express = require('express');
// const router = express.Router();
// const Service = require('../models/Service');
// const { ensureAuthenticated } = require('../config/auth');

// // Add a new service
// router.post('/add', ensureAuthenticated, async (req, res) => {
//     const { name, description, price, duration } = req.body;
//     try {
//         const newService = new Service({
//             provider: req.user.id,
//             name,
//             description,
//             price,
//             duration
//         });
//         await newService.save();
//         res.status(201).send('Service added successfully');
//     } catch (error) {
//         res.status(500).send('Error adding service');
//     }
// });

// // Update a service
// router.put('/update/:id', ensureAuthenticated, async (req, res) => {
//     const { name, description, price, duration } = req.body;
//     try {
//         await Service.findByIdAndUpdate(req.params.id, { name, description, price, duration });
//         res.status(200).send('Service updated successfully');
//     } catch (error) {
//         res.status(500).send('Error updating service');
//     }
// });

// // Delete a service
// router.delete('/delete/:id', ensureAuthenticated, async (req, res) => {
//     try {
//         await Service.findByIdAndRemove(req.params.id);
//         res.status(200).send('Service deleted successfully');
//     } catch (error) {
//         res.status(500).send('Error deleting service');
//     }
// });

// module.exports = router;
// routes/users.js
const express = require('express');
const router = express.Router();
const bcrypt = require('bcryptjs');
const passport = require('passport');
const User = require('../models/User');

// Register Page
router.get('/register', (req, res) => res.send('Register Page'));

// Register
router.post('/register', async (req, res) => {
    const { username, password } = req.body;
    let errors = [];

    if (!username || !password) {
        errors.push({ msg: 'Please enter all fields' });
    }

    if (password.length < 6) {
        errors.push({ msg: 'Password must be at least 6 characters' });
    }

    if (errors.length > 0) {
        res.status(400).json({ errors });
    } else {
        try {
            let user = await User.findOne({ username: username });
            if (user) {
                res.status(400).json({ errors: [{ msg: 'Username already exists' }] });
            } else {
                const newUser = new User({ username, password });

                // Hash password
                bcrypt.genSalt(10, (err, salt) => {
                    bcrypt.hash(newUser.password, salt, (err, hash) => {
                        if (err) throw err;
                        newUser.password = hash;
                        newUser.save()
                            .then(user => res.status(201).json({ msg: 'User registered', user }))
                            .catch(err => console.log(err));
                    });
                });
            }
        } catch (err) {
            console.log(err);
            res.status(500).send('Server error');
        }
    }
});

// Login Page
router.get('/login', (req, res) => res.send('Login Page'));

// Login
router.post('/login', (req, res, next) => {
    passport.authenticate('local', {
        successRedirect: '/dashboard',
        failureRedirect: '/login',
        failureFlash: true
    })(req, res, next);
});

// Logout
router.get('/logout', (req, res) => {
    req.logout();
    res.redirect('/login');
});

module.exports = router;
